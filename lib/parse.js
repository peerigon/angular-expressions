/* remove eslint errors to see if there is something really wrong */
/*eslint quotes: [0]*/
/*eslint indent: [0]*/
/*eslint vars-on-top: [0]*/
/*eslint yoda: 0*/
/*eslint curly: 0*/
/*eslint no-implicit-coercion: 0*/
/*eslint newline-after-var: 0*/
/*eslint space-before-function-paren: 0*/
/*eslint block-spacing: 0*/
/*eslint brace-style: 0*/
/*eslint complexity: 0*/
/*eslint one-var: 0*/
/*eslint eqeqeq: 0*/
/*eslint object-curly-spacing: 0*/
/*eslint quote-props: 0*/
/*eslint key-spacing: 0*/
/*eslint valid-jsdoc: 0*/
/*eslint func-style: 0*/
/*eslint no-nested-ternary: 0*/
/*eslint operator-linebreak: 0*/
/*eslint no-multi-spaces: 0*/
/*eslint no-constant-condition: 0*/
/*eslint comma-spacing: 0*/
/*eslint no-else-return: 0*/
/*eslint no-warning-comments: 0*/
/*eslint default-case: 0*/
/*eslint consistent-return: 0*/
/*eslint no-undefined: 0*/
/*eslint no-new-func: 0*/
/*eslint max-nested-callbacks: 0*/
/*eslint padded-blocks: 0*/
/*eslint no-self-compare: 0*/
/*eslint no-multiple-empty-lines: 0*/
/*eslint no-new: 0*/
/*eslint no-unused-vars: 0*/
"use strict";

var window = { document: {} };

/* We need to tell ESLint what variables are being exported */
/* exported
  angular,
  msie,
  jqLite,
  jQuery,
  slice,
  splice,
  push,
  toString,
  ngMinErr,
  angularModule,
  uid,
  REGEX_STRING_REGEXP,
  VALIDITY_STATE_PROPERTY,

  lowercase,
  uppercase,
  manualLowercase,
  manualUppercase,
  nodeName_,
  isArrayLike,
  forEach,
  forEachSorted,
  reverseParams,
  nextUid,
  setHashKey,
  extend,
  toInt,
  inherit,
  merge,
  noop,
  identity,
  valueFn,
  isUndefined,
  isDefined,
  isObject,
  isBlankObject,
  isString,
  isNumber,
  isNumberNaN,
  isDate,
  isArray,
  isFunction,
  isRegExp,
  isWindow,
  isScope,
  isFile,
  isFormData,
  isBlob,
  isBoolean,
  isPromiseLike,
  trim,
  escapeForRegexp,
  isElement,
  makeMap,
  includes,
  arrayRemove,
  copy,
  equals,
  csp,
  jq,
  concat,
  sliceArgs,
  bind,
  toJsonReplacer,
  toJson,
  fromJson,
  convertTimezoneToLocal,
  timezoneToOffset,
  startingTag,
  tryDecodeURIComponent,
  parseKeyValue,
  toKeyValue,
  encodeUriSegment,
  encodeUriQuery,
  angularInit,
  bootstrap,
  getTestability,
  snake_case,
  bindJQuery,
  assertArg,
  assertArgFn,
  assertNotHasOwnProperty,
  getter,
  getBlockNodes,
  hasOwnProperty,
  createMap,
  stringify,

  NODE_TYPE_ELEMENT,
  NODE_TYPE_ATTRIBUTE,
  NODE_TYPE_TEXT,
  NODE_TYPE_COMMENT,
  NODE_TYPE_DOCUMENT,
  NODE_TYPE_DOCUMENT_FRAGMENT
*/

////////////////////////////////////

/**
 * @ngdoc module
 * @name ng
 * @module ng
 * @installation
 * @description
 *
 * # ng (core module)
 * The ng module is loaded by default when an AngularJS application is started. The module itself
 * contains the essential components for an AngularJS application to function. The table below
 * lists a high level breakdown of each of the services/factories, filters, directives and testing
 * components available within this core module.
 *
 * <div doc-module-components="ng"></div>
 */

var NODE_TYPE_ELEMENT = 1;
var NODE_TYPE_ATTRIBUTE = 2;
var NODE_TYPE_TEXT = 3;
var NODE_TYPE_COMMENT = 8;
var NODE_TYPE_DOCUMENT = 9;
var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;

// The name of a form control's ValidityState property.
// This is used so that it's possible for internal tests to create mock ValidityStates.
var VALIDITY_STATE_PROPERTY = "validity";

var hasOwnProperty = Object.prototype.hasOwnProperty;

var lowercase = function (string) {
	return isString(string) ? string.toLowerCase() : string;
};
var uppercase = function (string) {
	return isString(string) ? string.toUpperCase() : string;
};

/**
 * @ngdoc function
 * @name angular.isArray
 * @module ng
 * @kind function
 *
 * @description
 * Determines if a reference is an `Array`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is an `Array`.
 */
var isArray = Array.isArray;

var ngAttrPrefixes = ["ng-", "data-ng-", "ng:", "x-ng-"];

var manualLowercase = function (s) {
	/* eslint-disable no-bitwise */
	return isString(s)
		? s.replace(/[A-Z]/g, function (ch) {
				return String.fromCharCode(ch.charCodeAt(0) | 32);
		  })
		: s;
	/* eslint-enable */
};
var manualUppercase = function (s) {
	/* eslint-disable no-bitwise */
	return isString(s)
		? s.replace(/[a-z]/g, function (ch) {
				return String.fromCharCode(ch.charCodeAt(0) & ~32);
		  })
		: s;
	/* eslint-enable */
};

// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish
// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods
// with correct but slower alternatives. See https://github.com/angular/angular.js/issues/11387
if ("i" !== "I".toLowerCase()) {
	lowercase = manualLowercase;
	uppercase = manualUppercase;
}

var msie, // holds major version number for IE, or NaN if UA is not IE.
	jqLite, // delay binding since jQuery could be loaded after us.
	jQuery, // delay binding
	slice = [].slice,
	splice = [].splice,
	push = [].push,
	toString = Object.prototype.toString,
	getPrototypeOf = Object.getPrototypeOf,
	ngMinErr = minErr("ng"),
	/** @name angular */
	angular = window.angular || (window.angular = {}),
	angularModule,
	uid = 0;

/**
 * documentMode is an IE-only property
 * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx
 */
msie = window.document.documentMode;

/**
 * @private
 * @param {*} obj
 * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,
 *                   String ...)
 */
function isArrayLike(obj) {
	// `null`, `undefined` and `window` are not array-like
	if (obj == null || isWindow(obj)) return false;

	// arrays, strings and jQuery/jqLite objects are array like
	// * jqLite is either the jQuery or jqLite constructor function
	// * we have to check the existence of jqLite first as this method is called
	//   via the forEach method when constructing the jqLite object in the first place
	if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
		return true;

	// Support: iOS 8.2 (not reproducible in simulator)
	// "length" in obj used to prevent JIT error (gh-11508)
	var length = "length" in Object(obj) && obj.length;

	// NodeList objects (with `item` method) and
	// other objects with suitable length characteristics are array-like
	return (
		isNumber(length) &&
		((length >= 0 && (length - 1 in obj || obj instanceof Array)) ||
			typeof obj.item === "function")
	);
}

/**
 * @ngdoc function
 * @name angular.forEach
 * @module ng
 * @kind function
 *
 * @description
 * Invokes the `iterator` function once for each item in `obj` collection, which can be either an
 * object or an array. The `iterator` function is invoked with `iterator(value, key, obj)`, where `value`
 * is the value of an object property or an array element, `key` is the object property key or
 * array element index and obj is the `obj` itself. Specifying a `context` for the function is optional.
 *
 * It is worth noting that `.forEach` does not iterate over inherited properties because it filters
 * using the `hasOwnProperty` method.
 *
 * Unlike ES262's
 * [Array.prototype.forEach](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18),
 * providing 'undefined' or 'null' values for `obj` will not throw a TypeError, but rather just
 * return the value provided.
 *
   ```js
     var values = {name: 'misko', gender: 'male'};
     var log = [];
     angular.forEach(values, function(value, key) {
       this.push(key + ': ' + value);
     }, log);
     expect(log).toEqual(['name: misko', 'gender: male']);
   ```
 *
 * @param {Object|Array} obj Object to iterate over.
 * @param {Function} iterator Iterator function.
 * @param {Object=} context Object to become context (`this`) for the iterator function.
 * @returns {Object|Array} Reference to `obj`.
 */

function forEach(obj, iterator, context) {
	var key, length;
	if (obj) {
		if (isFunction(obj)) {
			for (key in obj) {
				if (
					key !== "prototype" &&
					key !== "length" &&
					key !== "name" &&
					obj.hasOwnProperty(key)
				) {
					iterator.call(context, obj[key], key, obj);
				}
			}
		} else if (isArray(obj) || isArrayLike(obj)) {
			var isPrimitive = typeof obj !== "object";
			for (key = 0, length = obj.length; key < length; key++) {
				if (isPrimitive || key in obj) {
					iterator.call(context, obj[key], key, obj);
				}
			}
		} else if (obj.forEach && obj.forEach !== forEach) {
			obj.forEach(iterator, context, obj);
		} else if (isBlankObject(obj)) {
			// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty
			// eslint-disable-next-line guard-for-in
			for (key in obj) {
				iterator.call(context, obj[key], key, obj);
			}
		} else if (typeof obj.hasOwnProperty === "function") {
			// Slow path for objects inheriting Object.prototype, hasOwnProperty check needed
			for (key in obj) {
				if (obj.hasOwnProperty(key)) {
					iterator.call(context, obj[key], key, obj);
				}
			}
		} else {
			// Slow path for objects which do not have a method `hasOwnProperty`
			for (key in obj) {
				if (hasOwnProperty.call(obj, key)) {
					iterator.call(context, obj[key], key, obj);
				}
			}
		}
	}
	return obj;
}

function forEachSorted(obj, iterator, context) {
	var keys = Object.keys(obj).sort();
	for (var i = 0; i < keys.length; i++) {
		iterator.call(context, obj[keys[i]], keys[i]);
	}
	return keys;
}

/**
 * when using forEach the params are value, key, but it is often useful to have key, value.
 * @param {function(string, *)} iteratorFn
 * @returns {function(*, string)}
 */
function reverseParams(iteratorFn) {
	return function (value, key) {
		iteratorFn(key, value);
	};
}

/**
 * A consistent way of creating unique IDs in angular.
 *
 * Using simple numbers allows us to generate 28.6 million unique ids per second for 10 years before
 * we hit number precision issues in JavaScript.
 *
 * Math.pow(2,53) / 60 / 60 / 24 / 365 / 10 = 28.6M
 *
 * @returns {number} an unique alpha-numeric string
 */
function nextUid() {
	return ++uid;
}

/**
 * Set or clear the hashkey for an object.
 * @param obj object
 * @param h the hashkey (!truthy to delete the hashkey)
 */
function setHashKey(obj, h) {
	if (h) {
		obj.$$hashKey = h;
	} else {
		delete obj.$$hashKey;
	}
}

function baseExtend(dst, objs, deep) {
	var h = dst.$$hashKey;

	for (var i = 0, ii = objs.length; i < ii; ++i) {
		var obj = objs[i];
		if (!isObject(obj) && !isFunction(obj)) continue;
		var keys = Object.keys(obj);
		for (var j = 0, jj = keys.length; j < jj; j++) {
			var key = keys[j];
			var src = obj[key];

			if (deep && isObject(src)) {
				if (isDate(src)) {
					dst[key] = new Date(src.valueOf());
				} else if (isRegExp(src)) {
					dst[key] = new RegExp(src);
				} else if (src.nodeName) {
					dst[key] = src.cloneNode(true);
				} else if (isElement(src)) {
					dst[key] = src.clone();
				} else {
					if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
					baseExtend(dst[key], [src], true);
				}
			} else {
				dst[key] = src;
			}
		}
	}

	setHashKey(dst, h);
	return dst;
}

/**
 * @ngdoc function
 * @name angular.extend
 * @module ng
 * @kind function
 *
 * @description
 * Extends the destination object `dst` by copying own enumerable properties from the `src` object(s)
 * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so
 * by passing an empty object as the target: `var object = angular.extend({}, object1, object2)`.
 *
 * **Note:** Keep in mind that `angular.extend` does not support recursive merge (deep copy). Use
 * {@link angular.merge} for this.
 *
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to `dst`.
 */
function extend(dst) {
	return baseExtend(dst, slice.call(arguments, 1), false);
}

/**
 * @ngdoc function
 * @name angular.merge
 * @module ng
 * @kind function
 *
 * @description
 * Deeply extends the destination object `dst` by copying own enumerable properties from the `src` object(s)
 * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so
 * by passing an empty object as the target: `var object = angular.merge({}, object1, object2)`.
 *
 * Unlike {@link angular.extend extend()}, `merge()` recursively descends into object properties of source
 * objects, performing a deep copy.
 *
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to `dst`.
 */
function merge(dst) {
	return baseExtend(dst, slice.call(arguments, 1), true);
}

function toInt(str) {
	return parseInt(str, 10);
}

var isNumberNaN =
	Number.isNaN ||
	function isNumberNaN(num) {
		// eslint-disable-next-line no-self-compare
		return num !== num;
	};

function inherit(parent, extra) {
	return extend(Object.create(parent), extra);
}

/**
 * @ngdoc function
 * @name angular.noop
 * @module ng
 * @kind function
 *
 * @description
 * A function that performs no operations. This function can be useful when writing code in the
 * functional style.
   ```js
     function foo(callback) {
       var result = calculateResult();
       (callback || angular.noop)(result);
     }
   ```
 */
function noop() {}
noop.$inject = [];

/**
 * @ngdoc function
 * @name angular.identity
 * @module ng
 * @kind function
 *
 * @description
 * A function that returns its first argument. This function is useful when writing code in the
 * functional style.
 *
   ```js
   function transformer(transformationFn, value) {
     return (transformationFn || angular.identity)(value);
   };

   // E.g.
   function getResult(fn, input) {
     return (fn || angular.identity)(input);
   };

   getResult(function(n) { return n * 2; }, 21);   // returns 42
   getResult(null, 21);                            // returns 21
   getResult(undefined, 21);                       // returns 21
   ```
 *
 * @param {*} value to be returned.
 * @returns {*} the value passed in.
 */
function identity($) {
	return $;
}
identity.$inject = [];

function valueFn(value) {
	return function valueRef() {
		return value;
	};
}

function hasCustomToString(obj) {
	return isFunction(obj.toString) && obj.toString !== toString;
}

/**
 * @ngdoc function
 * @name angular.isUndefined
 * @module ng
 * @kind function
 *
 * @description
 * Determines if a reference is undefined.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is undefined.
 */
function isUndefined(value) {
	return typeof value === "undefined";
}

/**
 * @ngdoc function
 * @name angular.isDefined
 * @module ng
 * @kind function
 *
 * @description
 * Determines if a reference is defined.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is defined.
 */
function isDefined(value) {
	return typeof value !== "undefined";
}

/**
 * @ngdoc function
 * @name angular.isObject
 * @module ng
 * @kind function
 *
 * @description
 * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not
 * considered to be objects. Note that JavaScript arrays are objects.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is an `Object` but not `null`.
 */
function isObject(value) {
	// http://jsperf.com/isobject4
	return value !== null && typeof value === "object";
}

/**
 * Determine if a value is an object with a null prototype
 *
 * @returns {boolean} True if `value` is an `Object` with a null prototype
 */
function isBlankObject(value) {
	return value !== null && typeof value === "object" && !getPrototypeOf(value);
}

/**
 * @ngdoc function
 * @name angular.isString
 * @module ng
 * @kind function
 *
 * @description
 * Determines if a reference is a `String`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `String`.
 */
function isString(value) {
	return typeof value === "string";
}

/**
 * @ngdoc function
 * @name angular.isNumber
 * @module ng
 * @kind function
 *
 * @description
 * Determines if a reference is a `Number`.
 *
 * This includes the "special" numbers `NaN`, `+Infinity` and `-Infinity`.
 *
 * If you wish to exclude these then you can use the native
 * [`isFinite'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite)
 * method.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Number`.
 */
function isNumber(value) {
	return typeof value === "number";
}

/**
 * @ngdoc function
 * @name angular.isDate
 * @module ng
 * @kind function
 *
 * @description
 * Determines if a value is a date.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Date`.
 */
function isDate(value) {
	return toString.call(value) === "[object Date]";
}

/**
 * @ngdoc function
 * @name angular.isFunction
 * @module ng
 * @kind function
 *
 * @description
 * Determines if a reference is a `Function`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Function`.
 */
function isFunction(value) {
	return typeof value === "function";
}

/**
 * Determines if a value is a regular expression object.
 *
 * @private
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `RegExp`.
 */
function isRegExp(value) {
	return toString.call(value) === "[object RegExp]";
}

/**
 * Checks if `obj` is a window object.
 *
 * @private
 * @param {*} obj Object to check
 * @returns {boolean} True if `obj` is a window obj.
 */
function isWindow(obj) {
	return obj && obj.window === obj;
}

function isScope(obj) {
	return obj && obj.$evalAsync && obj.$watch;
}

function isFile(obj) {
	return toString.call(obj) === "[object File]";
}

function isFormData(obj) {
	return toString.call(obj) === "[object FormData]";
}

function isBlob(obj) {
	return toString.call(obj) === "[object Blob]";
}

function isBoolean(value) {
	return typeof value === "boolean";
}

function isPromiseLike(obj) {
	return obj && isFunction(obj.then);
}

var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
function isTypedArray(value) {
	return (
		value &&
		isNumber(value.length) &&
		TYPED_ARRAY_REGEXP.test(toString.call(value))
	);
}

function isArrayBuffer(obj) {
	return toString.call(obj) === "[object ArrayBuffer]";
}

var trim = function (value) {
	return isString(value) ? value.trim() : value;
};

// Copied from:
// http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021
// Prereq: s is a string.
var escapeForRegexp = function (s) {
	return (
		s
			.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1")
			// eslint-disable-next-line no-control-regex
			.replace(/\x08/g, "\\x08")
	);
};

/**
 * @ngdoc function
 * @name angular.isElement
 * @module ng
 * @kind function
 *
 * @description
 * Determines if a reference is a DOM element (or wrapped jQuery element).
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).
 */
function isElement(node) {
	return !!(
		node &&
		(node.nodeName || // We are a direct element.
			(node.prop && node.attr && node.find))
	); // We have an on and find method part of jQuery API.
}

/**
 * @param str 'key1,key2,...'
 * @returns {object} in the form of {key1:true, key2:true, ...}
 */
function makeMap(str) {
	var obj = {},
		items = str.split(","),
		i;
	for (i = 0; i < items.length; i++) {
		obj[items[i]] = true;
	}
	return obj;
}

function nodeName_(element) {
	return lowercase(element.nodeName || (element[0] && element[0].nodeName));
}

function includes(array, obj) {
	return Array.prototype.indexOf.call(array, obj) !== -1;
}

function arrayRemove(array, value) {
	var index = array.indexOf(value);
	if (index >= 0) {
		array.splice(index, 1);
	}
	return index;
}

/**
 * @ngdoc function
 * @name angular.copy
 * @module ng
 * @kind function
 *
 * @description
 * Creates a deep copy of `source`, which should be an object or an array.
 *
 * * If no destination is supplied, a copy of the object or array is created.
 * * If a destination is provided, all of its elements (for arrays) or properties (for objects)
 *   are deleted and then all elements/properties from the source are copied to it.
 * * If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.
 * * If `source` is identical to `destination` an exception will be thrown.
 *
 * <br />
 * <div class="alert alert-warning">
 *   Only enumerable properties are taken into account. Non-enumerable properties (both on `source`
 *   and on `destination`) will be ignored.
 * </div>
 *
 * @param {*} source The source that will be used to make a copy.
 *                   Can be any type, including primitives, `null`, and `undefined`.
 * @param {(Object|Array)=} destination Destination into which the source is copied. If
 *     provided, must be of the same type as `source`.
 * @returns {*} The copy or updated `destination`, if `destination` was specified.
 *
 * @example
  <example module="copyExample" name="angular-copy">
    <file name="index.html">
      <div ng-controller="ExampleController">
        <form novalidate class="simple-form">
          <label>Name: <input type="text" ng-model="user.name" /></label><br />
          <label>Age:  <input type="number" ng-model="user.age" /></label><br />
          Gender: <label><input type="radio" ng-model="user.gender" value="male" />male</label>
                  <label><input type="radio" ng-model="user.gender" value="female" />female</label><br />
          <button ng-click="reset()">RESET</button>
          <button ng-click="update(user)">SAVE</button>
        </form>
        <pre>form = {{user | json}}</pre>
        <pre>master = {{master | json}}</pre>
      </div>
    </file>
    <file name="script.js">
      // Module: copyExample
      angular.
        module('copyExample', []).
        controller('ExampleController', ['$scope', function($scope) {
          $scope.master = {};

          $scope.reset = function() {
            // Example with 1 argument
            $scope.user = angular.copy($scope.master);
          };

          $scope.update = function(user) {
            // Example with 2 arguments
            angular.copy(user, $scope.master);
          };

          $scope.reset();
        }]);
    </file>
  </example>
 */
function copy(source, destination) {
	var stackSource = [];
	var stackDest = [];

	if (destination) {
		if (isTypedArray(destination) || isArrayBuffer(destination)) {
			throw ngMinErr(
				"cpta",
				"Can't copy! TypedArray destination cannot be mutated."
			);
		}
		if (source === destination) {
			throw ngMinErr(
				"cpi",
				"Can't copy! Source and destination are identical."
			);
		}

		// Empty the destination object
		if (isArray(destination)) {
			destination.length = 0;
		} else {
			forEach(destination, function (value, key) {
				if (key !== "$$hashKey") {
					delete destination[key];
				}
			});
		}

		stackSource.push(source);
		stackDest.push(destination);
		return copyRecurse(source, destination);
	}

	return copyElement(source);

	function copyRecurse(source, destination) {
		var h = destination.$$hashKey;
		var key;
		if (isArray(source)) {
			for (var i = 0, ii = source.length; i < ii; i++) {
				destination.push(copyElement(source[i]));
			}
		} else if (isBlankObject(source)) {
			// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty
			// eslint-disable-next-line guard-for-in
			for (key in source) {
				destination[key] = copyElement(source[key]);
			}
		} else if (source && typeof source.hasOwnProperty === "function") {
			// Slow path, which must rely on hasOwnProperty
			for (key in source) {
				if (source.hasOwnProperty(key)) {
					destination[key] = copyElement(source[key]);
				}
			}
		} else {
			// Slowest path --- hasOwnProperty can't be called as a method
			for (key in source) {
				if (hasOwnProperty.call(source, key)) {
					destination[key] = copyElement(source[key]);
				}
			}
		}
		setHashKey(destination, h);
		return destination;
	}

	function copyElement(source) {
		// Simple values
		if (!isObject(source)) {
			return source;
		}

		// Already copied values
		var index = stackSource.indexOf(source);
		if (index !== -1) {
			return stackDest[index];
		}

		if (isWindow(source) || isScope(source)) {
			throw ngMinErr(
				"cpws",
				"Can't copy! Making copies of Window or Scope instances is not supported."
			);
		}

		var needsRecurse = false;
		var destination = copyType(source);

		if (destination === undefined) {
			destination = isArray(source)
				? []
				: Object.create(getPrototypeOf(source));
			needsRecurse = true;
		}

		stackSource.push(source);
		stackDest.push(destination);

		return needsRecurse ? copyRecurse(source, destination) : destination;
	}

	function copyType(source) {
		switch (toString.call(source)) {
			case "[object Int8Array]":
			case "[object Int16Array]":
			case "[object Int32Array]":
			case "[object Float32Array]":
			case "[object Float64Array]":
			case "[object Uint8Array]":
			case "[object Uint8ClampedArray]":
			case "[object Uint16Array]":
			case "[object Uint32Array]":
				return new source.constructor(
					copyElement(source.buffer),
					source.byteOffset,
					source.length
				);

			case "[object ArrayBuffer]":
				// Support: IE10
				if (!source.slice) {
					// If we're in this case we know the environment supports ArrayBuffer
					/* eslint-disable no-undef */
					var copied = new ArrayBuffer(source.byteLength);
					new Uint8Array(copied).set(new Uint8Array(source));
					/* eslint-enable */
					return copied;
				}
				return source.slice(0);

			case "[object Boolean]":
			case "[object Number]":
			case "[object String]":
			case "[object Date]":
				return new source.constructor(source.valueOf());

			case "[object RegExp]":
				var re = new RegExp(
					source.source,
					source.toString().match(/[^\/]*$/)[0]
				);
				re.lastIndex = source.lastIndex;
				return re;

			case "[object Blob]":
				return new source.constructor([source], { type: source.type });
		}

		if (isFunction(source.cloneNode)) {
			return source.cloneNode(true);
		}
	}
}

/**
 * @ngdoc function
 * @name angular.equals
 * @module ng
 * @kind function
 *
 * @description
 * Determines if two objects or two values are equivalent. Supports value types, regular
 * expressions, arrays and objects.
 *
 * Two objects or values are considered equivalent if at least one of the following is true:
 *
 * * Both objects or values pass `===` comparison.
 * * Both objects or values are of the same type and all of their properties are equal by
 *   comparing them with `angular.equals`.
 * * Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)
 * * Both values represent the same regular expression (In JavaScript,
 *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual
 *   representation matches).
 *
 * During a property comparison, properties of `function` type and properties with names
 * that begin with `$` are ignored.
 *
 * Scope and DOMWindow objects are being compared only by identify (`===`).
 *
 * @param {*} o1 Object or value to compare.
 * @param {*} o2 Object or value to compare.
 * @returns {boolean} True if arguments are equal.
 *
 * @example
   <example module="equalsExample" name="equalsExample">
     <file name="index.html">
      <div ng-controller="ExampleController">
        <form novalidate>
          <h3>User 1</h3>
          Name: <input type="text" ng-model="user1.name">
          Age: <input type="number" ng-model="user1.age">

          <h3>User 2</h3>
          Name: <input type="text" ng-model="user2.name">
          Age: <input type="number" ng-model="user2.age">

          <div>
            <br/>
            <input type="button" value="Compare" ng-click="compare()">
          </div>
          User 1: <pre>{{user1 | json}}</pre>
          User 2: <pre>{{user2 | json}}</pre>
          Equal: <pre>{{result}}</pre>
        </form>
      </div>
    </file>
    <file name="script.js">
        angular.module('equalsExample', []).controller('ExampleController', ['$scope', function($scope) {
          $scope.user1 = {};
          $scope.user2 = {};
          $scope.compare = function() {
            $scope.result = angular.equals($scope.user1, $scope.user2);
          };
        }]);
    </file>
  </example>
 */
function equals(o1, o2) {
	if (o1 === o2) return true;
	if (o1 === null || o2 === null) return false;
	// eslint-disable-next-line no-self-compare
	if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
	var t1 = typeof o1,
		t2 = typeof o2,
		length,
		key,
		keySet;
	if (t1 === t2 && t1 === "object") {
		if (isArray(o1)) {
			if (!isArray(o2)) return false;
			if ((length = o1.length) === o2.length) {
				for (key = 0; key < length; key++) {
					if (!equals(o1[key], o2[key])) return false;
				}
				return true;
			}
		} else if (isDate(o1)) {
			if (!isDate(o2)) return false;
			return equals(o1.getTime(), o2.getTime());
		} else if (isRegExp(o1)) {
			if (!isRegExp(o2)) return false;
			return o1.toString() === o2.toString();
		} else {
			if (
				isScope(o1) ||
				isScope(o2) ||
				isWindow(o1) ||
				isWindow(o2) ||
				isArray(o2) ||
				isDate(o2) ||
				isRegExp(o2)
			)
				return false;
			keySet = createMap();
			for (key in o1) {
				if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
				if (!equals(o1[key], o2[key])) return false;
				keySet[key] = true;
			}
			for (key in o2) {
				if (
					!(key in keySet) &&
					key.charAt(0) !== "$" &&
					isDefined(o2[key]) &&
					!isFunction(o2[key])
				)
					return false;
			}
			return true;
		}
	}
	return false;
}

var csp = function () {
	if (!isDefined(csp.rules)) {
		var ngCspElement =
			window.document.querySelector("[ng-csp]") ||
			window.document.querySelector("[data-ng-csp]");

		if (ngCspElement) {
			var ngCspAttribute =
				ngCspElement.getAttribute("ng-csp") ||
				ngCspElement.getAttribute("data-ng-csp");
			csp.rules = {
				noUnsafeEval:
					!ngCspAttribute || ngCspAttribute.indexOf("no-unsafe-eval") !== -1,
				noInlineStyle:
					!ngCspAttribute || ngCspAttribute.indexOf("no-inline-style") !== -1,
			};
		} else {
			csp.rules = {
				noUnsafeEval: noUnsafeEval(),
				noInlineStyle: false,
			};
		}
	}

	return csp.rules;

	function noUnsafeEval() {
		try {
			// eslint-disable-next-line no-new, no-new-func
			new Function("");
			return false;
		} catch (e) {
			return true;
		}
	}
};

/**
 * @ngdoc directive
 * @module ng
 * @name ngJq
 *
 * @element ANY
 * @param {string=} ngJq the name of the library available under `window`
 * to be used for angular.element
 * @description
 * Use this directive to force the angular.element library.  This should be
 * used to force either jqLite by leaving ng-jq blank or setting the name of
 * the jquery variable under window (eg. jQuery).
 *
 * Since angular looks for this directive when it is loaded (doesn't wait for the
 * DOMContentLoaded event), it must be placed on an element that comes before the script
 * which loads angular. Also, only the first instance of `ng-jq` will be used and all
 * others ignored.
 *
 * @example
 * This example shows how to force jqLite using the `ngJq` directive to the `html` tag.
 ```html
 <!doctype html>
 <html ng-app ng-jq>
 ...
 ...
 </html>
 ```
 * @example
 * This example shows how to use a jQuery based library of a different name.
 * The library name must be available at the top most 'window'.
 ```html
 <!doctype html>
 <html ng-app ng-jq="jQueryLib">
 ...
 ...
 </html>
 ```
 */
var jq = function () {
	if (isDefined(jq.name_)) return jq.name_;
	var el;
	var i,
		ii = ngAttrPrefixes.length,
		prefix,
		name;
	for (i = 0; i < ii; ++i) {
		prefix = ngAttrPrefixes[i];
		el = window.document.querySelector(
			"[" + prefix.replace(":", "\\:") + "jq]"
		);
		if (el) {
			name = el.getAttribute(prefix + "jq");
			break;
		}
	}

	return (jq.name_ = name);
};

function concat(array1, array2, index) {
	return array1.concat(slice.call(array2, index));
}

function sliceArgs(args, startIndex) {
	return slice.call(args, startIndex || 0);
}

/**
 * @ngdoc function
 * @name angular.bind
 * @module ng
 * @kind function
 *
 * @description
 * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for
 * `fn`). You can supply optional `args` that are prebound to the function. This feature is also
 * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as
 * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).
 *
 * @param {Object} self Context which `fn` should be evaluated in.
 * @param {function()} fn Function to be bound.
 * @param {...*} args Optional arguments to be prebound to the `fn` function call.
 * @returns {function()} Function that wraps the `fn` with all the specified bindings.
 */
// eslint-disable-next-line consistent-this
function bind(self, fn) {
	var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
	if (isFunction(fn) && !(fn instanceof RegExp)) {
		return curryArgs.length
			? function () {
					return arguments.length
						? fn.apply(self, concat(curryArgs, arguments, 0))
						: fn.apply(self, curryArgs);
			  }
			: function () {
					return arguments.length ? fn.apply(self, arguments) : fn.call(self);
			  };
	} else {
		// In IE, native methods are not functions so they cannot be bound (note: they don't need to be).
		return fn;
	}
}

function toJsonReplacer(key, value) {
	var val = value;

	if (
		typeof key === "string" &&
		key.charAt(0) === "$" &&
		key.charAt(1) === "$"
	) {
		val = undefined;
	} else if (isWindow(value)) {
		val = "$WINDOW";
	} else if (value && window.document === value) {
		val = "$DOCUMENT";
	} else if (isScope(value)) {
		val = "$SCOPE";
	}

	return val;
}

/**
 * @ngdoc function
 * @name angular.toJson
 * @module ng
 * @kind function
 *
 * @description
 * Serializes input into a JSON-formatted string. Properties with leading $$ characters will be
 * stripped since angular uses this notation internally.
 *
 * @param {Object|Array|Date|string|number|boolean} obj Input to be serialized into JSON.
 * @param {boolean|number} [pretty=2] If set to true, the JSON output will contain newlines and whitespace.
 *    If set to an integer, the JSON output will contain that many spaces per indentation.
 * @returns {string|undefined} JSON-ified string representing `obj`.
 * @knownIssue
 *
 * The Safari browser throws a `RangeError` instead of returning `null` when it tries to stringify a `Date`
 * object with an invalid date value. The only reliable way to prevent this is to monkeypatch the
 * `Date.prototype.toJSON` method as follows:
 *
 * ```
 * var _DatetoJSON = Date.prototype.toJSON;
 * Date.prototype.toJSON = function() {
 *   try {
 *     return _DatetoJSON.call(this);
 *   } catch(e) {
 *     if (e instanceof RangeError) {
 *       return null;
 *     }
 *     throw e;
 *   }
 * };
 * ```
 *
 * See https://github.com/angular/angular.js/pull/14221 for more information.
 */
function toJson(obj, pretty) {
	if (isUndefined(obj)) return undefined;
	if (!isNumber(pretty)) {
		pretty = pretty ? 2 : null;
	}
	return JSON.stringify(obj, toJsonReplacer, pretty);
}

/**
 * @ngdoc function
 * @name angular.fromJson
 * @module ng
 * @kind function
 *
 * @description
 * Deserializes a JSON string.
 *
 * @param {string} json JSON string to deserialize.
 * @returns {Object|Array|string|number} Deserialized JSON string.
 */
function fromJson(json) {
	return isString(json) ? JSON.parse(json) : json;
}

var ALL_COLONS = /:/g;
function timezoneToOffset(timezone, fallback) {
	// IE/Edge do not "understand" colon (`:`) in timezone
	timezone = timezone.replace(ALL_COLONS, "");
	var requestedTimezoneOffset =
		Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 60000;
	return isNumberNaN(requestedTimezoneOffset)
		? fallback
		: requestedTimezoneOffset;
}

function addDateMinutes(date, minutes) {
	date = new Date(date.getTime());
	date.setMinutes(date.getMinutes() + minutes);
	return date;
}

function convertTimezoneToLocal(date, timezone, reverse) {
	reverse = reverse ? -1 : 1;
	var dateTimezoneOffset = date.getTimezoneOffset();
	var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
	return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
}

/**
 * @returns {string} Returns the string representation of the element.
 */
function startingTag(element) {
	element = jqLite(element).clone();
	try {
		// turns out IE does not let you set .html() on elements which
		// are not allowed to have children. So we just ignore it.
		element.empty();
	} catch (e) {
		/* empty */
	}
	var elemHtml = jqLite("<div>").append(element).html();
	try {
		return element[0].nodeType === NODE_TYPE_TEXT
			? lowercase(elemHtml)
			: elemHtml
					.match(/^(<[^>]+>)/)[1]
					.replace(/^<([\w\-]+)/, function (match, nodeName) {
						return "<" + lowercase(nodeName);
					});
	} catch (e) {
		return lowercase(elemHtml);
	}
}

/////////////////////////////////////////////////

/**
 * Tries to decode the URI component without throwing an exception.
 *
 * @private
 * @param str value potential URI component to check.
 * @returns {boolean} True if `value` can be decoded
 * with the decodeURIComponent function.
 */
function tryDecodeURIComponent(value) {
	try {
		return decodeURIComponent(value);
	} catch (e) {
		// Ignore any invalid uri component.
	}
}

/**
 * Parses an escaped url query string into key-value pairs.
 * @returns {Object.<string,boolean|Array>}
 */
function parseKeyValue(/**string*/ keyValue) {
	var obj = {};
	forEach((keyValue || "").split("&"), function (keyValue) {
		var splitPoint, key, val;
		if (keyValue) {
			key = keyValue = keyValue.replace(/\+/g, "%20");
			splitPoint = keyValue.indexOf("=");
			if (splitPoint !== -1) {
				key = keyValue.substring(0, splitPoint);
				val = keyValue.substring(splitPoint + 1);
			}
			key = tryDecodeURIComponent(key);
			if (isDefined(key)) {
				val = isDefined(val) ? tryDecodeURIComponent(val) : true;
				if (!hasOwnProperty.call(obj, key)) {
					obj[key] = val;
				} else if (isArray(obj[key])) {
					obj[key].push(val);
				} else {
					obj[key] = [obj[key], val];
				}
			}
		}
	});
	return obj;
}

function toKeyValue(obj) {
	var parts = [];
	forEach(obj, function (value, key) {
		if (isArray(value)) {
			forEach(value, function (arrayValue) {
				parts.push(
					encodeUriQuery(key, true) +
						(arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true))
				);
			});
		} else {
			parts.push(
				encodeUriQuery(key, true) +
					(value === true ? "" : "=" + encodeUriQuery(value, true))
			);
		}
	});
	return parts.length ? parts.join("&") : "";
}

/**
 * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
 * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
 * segments:
 *    segment       = *pchar
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeUriSegment(val) {
	return encodeUriQuery(val, true)
		.replace(/%26/gi, "&")
		.replace(/%3D/gi, "=")
		.replace(/%2B/gi, "+");
}

/**
 * This method is intended for encoding *key* or *value* parts of query component. We need a custom
 * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
 * encoded per http://tools.ietf.org/html/rfc3986:
 *    query         = *( pchar / "/" / "?" )
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeUriQuery(val, pctEncodeSpaces) {
	return encodeURIComponent(val)
		.replace(/%40/gi, "@")
		.replace(/%3A/gi, ":")
		.replace(/%24/g, "$")
		.replace(/%2C/gi, ",")
		.replace(/%3B/gi, ";")
		.replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
}

function getNgAttribute(element, ngAttr) {
	var attr,
		i,
		ii = ngAttrPrefixes.length;
	for (i = 0; i < ii; ++i) {
		attr = ngAttrPrefixes[i] + ngAttr;
		if (isString((attr = element.getAttribute(attr)))) {
			return attr;
		}
	}
	return null;
}

function allowAutoBootstrap(document) {
	if (!document.currentScript) {
		return true;
	}
	var src = document.currentScript.getAttribute("src");
	var link = document.createElement("a");
	link.href = src;
	var scriptProtocol = link.protocol;
	var docLoadProtocol = document.location.protocol;
	if (
		(scriptProtocol === "resource:" ||
			scriptProtocol === "chrome-extension:") &&
		docLoadProtocol !== scriptProtocol
	) {
		return false;
	}
	return true;
}

// Cached as it has to run during loading so that document.currentScript is available.
var isAutoBootstrapAllowed = allowAutoBootstrap(window.document);

/**
 * @ngdoc directive
 * @name ngApp
 * @module ng
 *
 * @element ANY
 * @param {angular.Module} ngApp an optional application
 *   {@link angular.module module} name to load.
 * @param {boolean=} ngStrictDi if this attribute is present on the app element, the injector will be
 *   created in "strict-di" mode. This means that the application will fail to invoke functions which
 *   do not use explicit function annotation (and are thus unsuitable for minification), as described
 *   in {@link guide/di the Dependency Injection guide}, and useful debugging info will assist in
 *   tracking down the root of these bugs.
 *
 * @description
 *
 * Use this directive to **auto-bootstrap** an AngularJS application. The `ngApp` directive
 * designates the **root element** of the application and is typically placed near the root element
 * of the page - e.g. on the `<body>` or `<html>` tags.
 *
 * There are a few things to keep in mind when using `ngApp`:
 * - only one AngularJS application can be auto-bootstrapped per HTML document. The first `ngApp`
 *   found in the document will be used to define the root element to auto-bootstrap as an
 *   application. To run multiple applications in an HTML document you must manually bootstrap them using
 *   {@link angular.bootstrap} instead.
 * - AngularJS applications cannot be nested within each other.
 * - Do not use a directive that uses {@link ng.$compile#transclusion transclusion} on the same element as `ngApp`.
 *   This includes directives such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and
 *   {@link ngRoute.ngView `ngView`}.
 *   Doing this misplaces the app {@link ng.$rootElement `$rootElement`} and the app's {@link auto.$injector injector},
 *   causing animations to stop working and making the injector inaccessible from outside the app.
 *
 * You can specify an **AngularJS module** to be used as the root module for the application.  This
 * module will be loaded into the {@link auto.$injector} when the application is bootstrapped. It
 * should contain the application code needed or have dependencies on other modules that will
 * contain the code. See {@link angular.module} for more information.
 *
 * In the example below if the `ngApp` directive were not placed on the `html` element then the
 * document would not be compiled, the `AppController` would not be instantiated and the `{{ a+b }}`
 * would not be resolved to `3`.
 *
 * `ngApp` is the easiest, and most common way to bootstrap an application.
 *
 <example module="ngAppDemo" name="ng-app">
   <file name="index.html">
   <div ng-controller="ngAppDemoController">
     I can add: {{a}} + {{b}} =  {{ a+b }}
   </div>
   </file>
   <file name="script.js">
   angular.module('ngAppDemo', []).controller('ngAppDemoController', function($scope) {
     $scope.a = 1;
     $scope.b = 2;
   });
   </file>
 </example>
 *
 * Using `ngStrictDi`, you would see something like this:
 *
 <example ng-app-included="true" name="strict-di">
   <file name="index.html">
   <div ng-app="ngAppStrictDemo" ng-strict-di>
       <div ng-controller="GoodController1">
           I can add: {{a}} + {{b}} =  {{ a+b }}

           <p>This renders because the controller does not fail to
              instantiate, by using explicit annotation style (see
              script.js for details)
           </p>
       </div>

       <div ng-controller="GoodController2">
           Name: <input ng-model="name"><br />
           Hello, {{name}}!

           <p>This renders because the controller does not fail to
              instantiate, by using explicit annotation style
              (see script.js for details)
           </p>
       </div>

       <div ng-controller="BadController">
           I can add: {{a}} + {{b}} =  {{ a+b }}

           <p>The controller could not be instantiated, due to relying
              on automatic function annotations (which are disabled in
              strict mode). As such, the content of this section is not
              interpolated, and there should be an error in your web console.
           </p>
       </div>
   </div>
   </file>
   <file name="script.js">
   angular.module('ngAppStrictDemo', [])
     // BadController will fail to instantiate, due to relying on automatic function annotation,
     // rather than an explicit annotation
     .controller('BadController', function($scope) {
       $scope.a = 1;
       $scope.b = 2;
     })
     // Unlike BadController, GoodController1 and GoodController2 will not fail to be instantiated,
     // due to using explicit annotations using the array style and $inject property, respectively.
     .controller('GoodController1', ['$scope', function($scope) {
       $scope.a = 1;
       $scope.b = 2;
     }])
     .controller('GoodController2', GoodController2);
     function GoodController2($scope) {
       $scope.name = 'World';
     }
     GoodController2.$inject = ['$scope'];
   </file>
   <file name="style.css">
   div[ng-controller] {
       margin-bottom: 1em;
       -webkit-border-radius: 4px;
       border-radius: 4px;
       border: 1px solid;
       padding: .5em;
   }
   div[ng-controller^=Good] {
       border-color: #d6e9c6;
       background-color: #dff0d8;
       color: #3c763d;
   }
   div[ng-controller^=Bad] {
       border-color: #ebccd1;
       background-color: #f2dede;
       color: #a94442;
       margin-bottom: 0;
   }
   </file>
 </example>
 */

/**
 * @ngdoc function
 * @name angular.bootstrap
 * @module ng
 * @description
 * Use this function to manually start up angular application.
 *
 * For more information, see the {@link guide/bootstrap Bootstrap guide}.
 *
 * Angular will detect if it has been loaded into the browser more than once and only allow the
 * first loaded script to be bootstrapped and will report a warning to the browser console for
 * each of the subsequent scripts. This prevents strange results in applications, where otherwise
 * multiple instances of Angular try to work on the DOM.
 *
 * <div class="alert alert-warning">
 * **Note:** Protractor based end-to-end tests cannot use this function to bootstrap manually.
 * They must use {@link ng.directive:ngApp ngApp}.
 * </div>
 *
 * <div class="alert alert-warning">
 * **Note:** Do not bootstrap the app on an element with a directive that uses {@link ng.$compile#transclusion transclusion},
 * such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and {@link ngRoute.ngView `ngView`}.
 * Doing this misplaces the app {@link ng.$rootElement `$rootElement`} and the app's {@link auto.$injector injector},
 * causing animations to stop working and making the injector inaccessible from outside the app.
 * </div>
 *
 * ```html
 * <!doctype html>
 * <html>
 * <body>
 * <div ng-controller="WelcomeController">
 *   {{greeting}}
 * </div>
 *
 * <script src="angular.js"></script>
 * <script>
 *   var app = angular.module('demo', [])
 *   .controller('WelcomeController', function($scope) {
 *       $scope.greeting = 'Welcome!';
 *   });
 *   angular.bootstrap(document, ['demo']);
 * </script>
 * </body>
 * </html>
 * ```
 *
 * @param {DOMElement} element DOM element which is the root of angular application.
 * @param {Array<String|Function|Array>=} modules an array of modules to load into the application.
 *     Each item in the array should be the name of a predefined module or a (DI annotated)
 *     function that will be invoked by the injector as a `config` block.
 *     See: {@link angular.module modules}
 * @param {Object=} config an object for defining configuration options for the application. The
 *     following keys are supported:
 *
 * * `strictDi` - disable automatic function annotation for the application. This is meant to
 *   assist in finding bugs which break minified code. Defaults to `false`.
 *
 * @returns {auto.$injector} Returns the newly created injector for this app.
 */
function bootstrap(element, modules, config) {
	if (!isObject(config)) config = {};
	var defaultConfig = {
		strictDi: false,
	};
	config = extend(defaultConfig, config);
	var doBootstrap = function () {
		element = jqLite(element);

		if (element.injector()) {
			var tag =
				element[0] === window.document ? "document" : startingTag(element);
			// Encode angle brackets to prevent input from being sanitized to empty string #8683.
			throw ngMinErr(
				"btstrpd",
				"App already bootstrapped with this element '{0}'",
				tag.replace(/</, "&lt;").replace(/>/, "&gt;")
			);
		}

		modules = modules || [];
		modules.unshift([
			"$provide",
			function ($provide) {
				$provide.value("$rootElement", element);
			},
		]);

		if (config.debugInfoEnabled) {
			// Pushing so that this overrides `debugInfoEnabled` setting defined in user's `modules`.
			modules.push([
				"$compileProvider",
				function ($compileProvider) {
					$compileProvider.debugInfoEnabled(true);
				},
			]);
		}

		modules.unshift("ng");
	};

	var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
	var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;

	if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
		config.debugInfoEnabled = true;
		window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "");
	}

	if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
		return doBootstrap();
	}

	window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
	angular.resumeBootstrap = function (extraModules) {
		forEach(extraModules, function (module) {
			modules.push(module);
		});
		return doBootstrap();
	};

	if (isFunction(angular.resumeDeferredBootstrap)) {
		angular.resumeDeferredBootstrap();
	}
}

/**
 * @ngdoc function
 * @name angular.reloadWithDebugInfo
 * @module ng
 * @description
 * Use this function to reload the current application with debug information turned on.
 * This takes precedence over a call to `$compileProvider.debugInfoEnabled(false)`.
 *
 * See {@link ng.$compileProvider#debugInfoEnabled} for more.
 */
function reloadWithDebugInfo() {
	window.name = "NG_ENABLE_DEBUG_INFO!" + window.name;
	window.location.reload();
}

/**
 * @name angular.getTestability
 * @module ng
 * @description
 * Get the testability service for the instance of Angular on the given
 * element.
 * @param {DOMElement} element DOM element which is the root of angular application.
 */
function getTestability(rootElement) {
	var injector = angular.element(rootElement).injector();
	if (!injector) {
		throw ngMinErr(
			"test",
			"no injector found for element argument to getTestability"
		);
	}
	return injector.get("$$testability");
}

var SNAKE_CASE_REGEXP = /[A-Z]/g;
function snake_case(name, separator) {
	separator = separator || "_";
	return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
		return (pos ? separator : "") + letter.toLowerCase();
	});
}

var bindJQueryFired = false;
function bindJQuery() {
	var originalCleanData;

	if (bindJQueryFired) {
		return;
	}

	// bind to jQuery if present;
	var jqName = jq();
	jQuery = isUndefined(jqName)
		? window.jQuery // use jQuery (if present)
		: !jqName
		? undefined // use jqLite
		: window[jqName]; // use jQuery specified by `ngJq`

	// Use jQuery if it exists with proper functionality, otherwise default to us.
	// Angular 1.2+ requires jQuery 1.7+ for on()/off() support.
	// Angular 1.3+ technically requires at least jQuery 2.1+ but it may work with older
	// versions. It will not work for sure with jQuery <1.7, though.
	if (jQuery && jQuery.fn.on) {
		jqLite = jQuery;
		extend(jQuery.fn, {
			scope: JQLitePrototype.scope,
			isolateScope: JQLitePrototype.isolateScope,
			controller: JQLitePrototype.controller,
			injector: JQLitePrototype.injector,
			inheritedData: JQLitePrototype.inheritedData,
		});

		// All nodes removed from the DOM via various jQuery APIs like .remove()
		// are passed through jQuery.cleanData. Monkey-patch this method to fire
		// the $destroy event on all removed nodes.
		originalCleanData = jQuery.cleanData;
		jQuery.cleanData = function (elems) {
			var events;
			for (var i = 0, elem; (elem = elems[i]) != null; i++) {
				events = jQuery._data(elem, "events");
				if (events && events.$destroy) {
					jQuery(elem).triggerHandler("$destroy");
				}
			}
			originalCleanData(elems);
		};
	} else {
		jqLite = JQLite;
	}

	angular.element = jqLite;

	// Prevent double-proxying.
	bindJQueryFired = true;
}

/**
 * throw error if the argument is falsy.
 */
function assertArg(arg, name, reason) {
	if (!arg) {
		throw ngMinErr(
			"areq",
			"Argument '{0}' is {1}",
			name || "?",
			reason || "required"
		);
	}
	return arg;
}

function assertArgFn(arg, name, acceptArrayAnnotation) {
	if (acceptArrayAnnotation && isArray(arg)) {
		arg = arg[arg.length - 1];
	}

	assertArg(
		isFunction(arg),
		name,
		"not a function, got " +
			(arg && typeof arg === "object"
				? arg.constructor.name || "Object"
				: typeof arg)
	);
	return arg;
}

/**
 * throw error if the name given is hasOwnProperty
 * @param  {String} name    the name to test
 * @param  {String} context the context in which the name is used, such as module or directive
 */
function assertNotHasOwnProperty(name, context) {
	if (name === "hasOwnProperty") {
		throw ngMinErr(
			"badname",
			"hasOwnProperty is not a valid {0} name",
			context
		);
	}
}

/**
 * Return the value accessible from the object by path. Any undefined traversals are ignored
 * @param {Object} obj starting object
 * @param {String} path path to traverse
 * @param {boolean} [bindFnToScope=true]
 * @returns {Object} value as accessible by path
 */
//TODO(misko): this function needs to be removed
function getter(obj, path, bindFnToScope) {
	if (!path) return obj;
	var keys = path.split(".");
	var key;
	var lastInstance = obj;
	var len = keys.length;

	for (var i = 0; i < len; i++) {
		key = keys[i];
		if (obj) {
			obj = (lastInstance = obj)[key];
		}
	}
	if (!bindFnToScope && isFunction(obj)) {
		return bind(lastInstance, obj);
	}
	return obj;
}

/**
 * Return the DOM siblings between the first and last node in the given array.
 * @param {Array} array like object
 * @returns {Array} the inputted object or a jqLite collection containing the nodes
 */
function getBlockNodes(nodes) {
	// TODO(perf): update `nodes` instead of creating a new object?
	var node = nodes[0];
	var endNode = nodes[nodes.length - 1];
	var blockNodes;

	for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
		if (blockNodes || nodes[i] !== node) {
			if (!blockNodes) {
				blockNodes = jqLite(slice.call(nodes, 0, i));
			}
			blockNodes.push(node);
		}
	}

	return blockNodes || nodes;
}

/**
 * Creates a new object without a prototype. This object is useful for lookup without having to
 * guard against prototypically inherited properties via hasOwnProperty.
 *
 * Related micro-benchmarks:
 * - http://jsperf.com/object-create2
 * - http://jsperf.com/proto-map-lookup/2
 * - http://jsperf.com/for-in-vs-object-keys2
 *
 * @returns {Object}
 */
function createMap() {
	return Object.create(null);
}

function stringify(value) {
	if (value == null) {
		// null || undefined
		return "";
	}
	switch (typeof value) {
		case "string":
			break;
		case "number":
			value = "" + value;
			break;
		default:
			if (hasCustomToString(value) && !isArray(value) && !isDate(value)) {
				value = value.toString();
			} else {
				value = toJson(value);
			}
	}

	return value;
}

/* global toDebugString: true */

function serializeObject(obj) {
	var seen = [];

	return JSON.stringify(obj, function (key, val) {
		val = toJsonReplacer(key, val);
		if (isObject(val)) {
			if (seen.indexOf(val) >= 0) return "...";

			seen.push(val);
		}
		return val;
	});
}

function toDebugString(obj) {
	if (typeof obj === "function") {
		return obj.toString().replace(/ \{[\s\S]*$/, "");
	} else if (isUndefined(obj)) {
		return "undefined";
	} else if (typeof obj !== "string") {
		return serializeObject(obj);
	}
	return obj;
}

/**
 * @description
 *
 * This object provides a utility for producing rich Error messages within
 * Angular. It can be called as follows:
 *
 * var exampleMinErr = minErr('example');
 * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);
 *
 * The above creates an instance of minErr in the example namespace. The
 * resulting error will have a namespaced error code of example.one.  The
 * resulting error will replace {0} with the value of foo, and {1} with the
 * value of bar. The object is not restricted in the number of arguments it can
 * take.
 *
 * If fewer arguments are specified than necessary for interpolation, the extra
 * interpolation markers will be preserved in the final string.
 *
 * Since data will be parsed statically during a build step, some restrictions
 * are applied with respect to how minErr instances are created and called.
 * Instances should have names of the form namespaceMinErr for a minErr created
 * using minErr('namespace') . Error codes, namespaces and template strings
 * should all be static strings, not variables or general expressions.
 *
 * @param {string} module The namespace to use for the new minErr instance.
 * @param {function} ErrorConstructor Custom error constructor to be instantiated when returning
 *   error from returned function, for cases when a particular type of error is useful.
 * @returns {function(code:string, template:string, ...templateArgs): Error} minErr instance
 */

function minErr(module, ErrorConstructor) {
	ErrorConstructor = ErrorConstructor || Error;
	return function () {
		var SKIP_INDEXES = 2;

		var templateArgs = arguments,
			code = templateArgs[0],
			message = "[" + (module ? module + ":" : "") + code + "] ",
			template = templateArgs[1],
			paramPrefix,
			i;

		message += template.replace(/\{\d+\}/g, function (match) {
			var index = +match.slice(1, -1),
				shiftedIndex = index + SKIP_INDEXES;

			if (shiftedIndex < templateArgs.length) {
				return toDebugString(templateArgs[shiftedIndex]);
			}

			return match;
		});

		message +=
			'\nhttp://errors.angularjs.org/"NG_VERSION_FULL"/' +
			(module ? module + "/" : "") +
			code;

		for (
			i = SKIP_INDEXES, paramPrefix = "?";
			i < templateArgs.length;
			i++, paramPrefix = "&"
		) {
			message +=
				paramPrefix +
				"p" +
				(i - SKIP_INDEXES) +
				"=" +
				encodeURIComponent(toDebugString(templateArgs[i]));
		}

		return new ErrorConstructor(message);
	};
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *     Any commits to this file should be reviewed with security in mind.  *
 *   Changes to this file can potentially create security vulnerabilities. *
 *          An approval from 2 Core members with history of modifying      *
 *                         this file is required.                          *
 *                                                                         *
 *  Does the change somehow allow for arbitrary javascript to be executed? *
 *    Or allows for someone to change the prototype of built-in objects?   *
 *     Or gives undesired access to variables likes document or window?    *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

var $parseMinErr = minErr("$parse");

var objectValueOf = {}.constructor.prototype.valueOf;

// Sandboxing Angular Expressions
// ------------------------------
// Angular expressions are no longer sandboxed. So it is now even easier to access arbitrary JS code by
// various means such as obtaining a reference to native JS functions like the Function constructor.
//
// As an example, consider the following Angular expression:
//
//   {}.toString.constructor('alert("evil JS code")')
//
// It is important to realize that if you create an expression from a string that contains user provided
// content then it is possible that your application contains a security vulnerability to an XSS style attack.
//
// See https://docs.angularjs.org/guide/security

function getStringValue(name) {
	// Property names must be strings. This means that non-string objects cannot be used
	// as keys in an object. Any non-string object, including a number, is typecasted
	// into a string via the toString method.
	// -- MDN, https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors#Property_names
	//
	// So, to ensure that we are checking the same `name` that JavaScript would use, we cast it
	// to a string. It's not always possible. If `name` is an object and its `toString` method is
	// 'broken' (doesn't return a string, isn't a function, etc.), an error will be thrown:
	//
	// TypeError: Cannot convert object to primitive value
	//
	// For performance reasons, we don't catch this error here and allow it to propagate up the call
	// stack. Note that you'll get the same error in JavaScript if you try to access a property using
	// such a 'broken' object as a key.
	return name + "";
}

var OPERATORS = createMap();
forEach(
	"+ - * / % === !== == != < > <= >= && || ! = |".split(" "),
	function (operator) {
		OPERATORS[operator] = true;
	}
);
var ESCAPE = {
	n: "\n",
	f: "\f",
	r: "\r",
	t: "\t",
	v: "\v",
	"'": "'",
	'"': '"',
};

/////////////////////////////////////////

/**
 * @constructor
 */
var Lexer = function Lexer(options) {
	this.options = options;
};

Lexer.prototype = {
	constructor: Lexer,

	lex: function (text) {
		this.text = text;
		this.index = 0;
		this.tokens = [];

		while (this.index < this.text.length) {
			var ch = this.text.charAt(this.index);
			if (ch === '"' || ch === "'") {
				this.readString(ch);
			} else if (
				this.isNumber(ch) ||
				(ch === "." && this.isNumber(this.peek()))
			) {
				this.readNumber();
			} else if (this.isIdentifierStart(this.peekMultichar())) {
				this.readIdent();
			} else if (this.is(ch, "(){}[].,;:?")) {
				this.tokens.push({ index: this.index, text: ch });
				this.index++;
			} else if (this.isWhitespace(ch)) {
				this.index++;
			} else {
				var ch2 = ch + this.peek();
				var ch3 = ch2 + this.peek(2);
				var op1 = OPERATORS[ch];
				var op2 = OPERATORS[ch2];
				var op3 = OPERATORS[ch3];
				if (op1 || op2 || op3) {
					var token = op3 ? ch3 : op2 ? ch2 : ch;
					this.tokens.push({ index: this.index, text: token, operator: true });
					this.index += token.length;
				} else {
					this.throwError(
						"Unexpected next character ",
						this.index,
						this.index + 1
					);
				}
			}
		}
		return this.tokens;
	},

	is: function (ch, chars) {
		return chars.indexOf(ch) !== -1;
	},

	peek: function (i) {
		var num = i || 1;
		return this.index + num < this.text.length
			? this.text.charAt(this.index + num)
			: false;
	},

	isNumber: function (ch) {
		return "0" <= ch && ch <= "9" && typeof ch === "string";
	},

	isWhitespace: function (ch) {
		// IE treats non-breaking space as \u00A0
		return (
			ch === " " ||
			ch === "\r" ||
			ch === "\t" ||
			ch === "\n" ||
			ch === "\v" ||
			ch === "\u00A0"
		);
	},

	isIdentifierStart: function (ch) {
		return this.options.isIdentifierStart
			? this.options.isIdentifierStart(ch, this.codePointAt(ch))
			: this.isValidIdentifierStart(ch);
	},

	isValidIdentifierStart: function (ch) {
		return (
			("a" <= ch && ch <= "z") ||
			("A" <= ch && ch <= "Z") ||
			"_" === ch ||
			ch === "$"
		);
	},

	isIdentifierContinue: function (ch) {
		return this.options.isIdentifierContinue
			? this.options.isIdentifierContinue(ch, this.codePointAt(ch))
			: this.isValidIdentifierContinue(ch);
	},

	isValidIdentifierContinue: function (ch, cp) {
		return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
	},

	codePointAt: function (ch) {
		if (ch.length === 1) return ch.charCodeAt(0);
		// eslint-disable-next-line no-bitwise
		return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35fdc00;
	},

	peekMultichar: function () {
		var ch = this.text.charAt(this.index);
		var peek = this.peek();
		if (!peek) {
			return ch;
		}
		var cp1 = ch.charCodeAt(0);
		var cp2 = peek.charCodeAt(0);
		if (cp1 >= 0xd800 && cp1 <= 0xdbff && cp2 >= 0xdc00 && cp2 <= 0xdfff) {
			return ch + peek;
		}
		return ch;
	},

	isExpOperator: function (ch) {
		return ch === "-" || ch === "+" || this.isNumber(ch);
	},

	throwError: function (error, start, end) {
		end = end || this.index;
		var colStr = isDefined(start)
			? "s " +
			  start +
			  "-" +
			  this.index +
			  " [" +
			  this.text.substring(start, end) +
			  "]"
			: " " + end;
		throw $parseMinErr(
			"lexerr",
			"Lexer Error: {0} at column{1} in expression [{2}].",
			error,
			colStr,
			this.text
		);
	},

	readNumber: function () {
		var number = "";
		var start = this.index;
		while (this.index < this.text.length) {
			var ch = lowercase(this.text.charAt(this.index));
			if (ch === "." || this.isNumber(ch)) {
				number += ch;
			} else {
				var peekCh = this.peek();
				if (ch === "e" && this.isExpOperator(peekCh)) {
					number += ch;
				} else if (
					this.isExpOperator(ch) &&
					peekCh &&
					this.isNumber(peekCh) &&
					number.charAt(number.length - 1) === "e"
				) {
					number += ch;
				} else if (
					this.isExpOperator(ch) &&
					(!peekCh || !this.isNumber(peekCh)) &&
					number.charAt(number.length - 1) === "e"
				) {
					this.throwError("Invalid exponent");
				} else {
					break;
				}
			}
			this.index++;
		}
		this.tokens.push({
			index: start,
			text: number,
			constant: true,
			value: Number(number),
		});
	},

	readIdent: function () {
		var start = this.index;
		this.index += this.peekMultichar().length;
		while (this.index < this.text.length) {
			var ch = this.peekMultichar();
			if (!this.isIdentifierContinue(ch)) {
				break;
			}
			this.index += ch.length;
		}
		this.tokens.push({
			index: start,
			text: this.text.slice(start, this.index),
			identifier: true,
		});
	},

	readString: function (quote) {
		var start = this.index;
		this.index++;
		var string = "";
		var rawString = quote;
		var escape = false;
		while (this.index < this.text.length) {
			var ch = this.text.charAt(this.index);
			rawString += ch;
			if (escape) {
				if (ch === "u") {
					var hex = this.text.substring(this.index + 1, this.index + 5);
					if (!hex.match(/[\da-f]{4}/i)) {
						this.throwError("Invalid unicode escape [\\u" + hex + "]");
					}
					this.index += 4;
					string += String.fromCharCode(parseInt(hex, 16));
				} else {
					var rep = ESCAPE[ch];
					string = string + (rep || ch);
				}
				escape = false;
			} else if (ch === "\\") {
				escape = true;
			} else if (ch === quote) {
				this.index++;
				this.tokens.push({
					index: start,
					text: rawString,
					constant: true,
					value: string,
				});
				return;
			} else {
				string += ch;
			}
			this.index++;
		}
		this.throwError("Unterminated quote", start);
	},
};

var AST = function AST(lexer, options) {
	this.lexer = lexer;
	this.options = options;
};

AST.Program = "Program";
AST.ExpressionStatement = "ExpressionStatement";
AST.AssignmentExpression = "AssignmentExpression";
AST.ConditionalExpression = "ConditionalExpression";
AST.LogicalExpression = "LogicalExpression";
AST.BinaryExpression = "BinaryExpression";
AST.UnaryExpression = "UnaryExpression";
AST.CallExpression = "CallExpression";
AST.MemberExpression = "MemberExpression";
AST.Identifier = "Identifier";
AST.Literal = "Literal";
AST.ArrayExpression = "ArrayExpression";
AST.Property = "Property";
AST.ObjectExpression = "ObjectExpression";
AST.ThisExpression = "ThisExpression";
AST.LocalsExpression = "LocalsExpression";

// Internal use only
AST.NGValueParameter = "NGValueParameter";

AST.prototype = {
	ast: function (text) {
		this.text = text;
		this.tokens = this.lexer.lex(text);

		var value = this.program();

		if (this.tokens.length !== 0) {
			this.throwError("is an unexpected token", this.tokens[0]);
		}

		return value;
	},

	program: function () {
		var body = [];
		while (true) {
			if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]"))
				body.push(this.expressionStatement());
			if (!this.expect(";")) {
				return { type: AST.Program, body: body };
			}
		}
	},

	expressionStatement: function () {
		return { type: AST.ExpressionStatement, expression: this.filterChain() };
	},

	filterChain: function () {
		var left = this.expression();
		while (this.expect("|")) {
			left = this.filter(left);
		}
		return left;
	},

	expression: function () {
		return this.assignment();
	},

	assignment: function () {
		var result = this.ternary();
		if (this.expect("=")) {
			if (!isAssignable(result)) {
				throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
			}

			result = {
				type: AST.AssignmentExpression,
				left: result,
				right: this.assignment(),
				operator: "=",
			};
		}
		return result;
	},

	ternary: function () {
		var test = this.logicalOR();
		var alternate;
		var consequent;
		if (this.expect("?")) {
			alternate = this.expression();
			if (this.consume(":")) {
				consequent = this.expression();
				return {
					type: AST.ConditionalExpression,
					test: test,
					alternate: alternate,
					consequent: consequent,
				};
			}
		}
		return test;
	},

	logicalOR: function () {
		var left = this.logicalAND();
		while (this.expect("||")) {
			left = {
				type: AST.LogicalExpression,
				operator: "||",
				left: left,
				right: this.logicalAND(),
			};
		}
		return left;
	},

	logicalAND: function () {
		var left = this.equality();
		while (this.expect("&&")) {
			left = {
				type: AST.LogicalExpression,
				operator: "&&",
				left: left,
				right: this.equality(),
			};
		}
		return left;
	},

	equality: function () {
		var left = this.relational();
		var token;
		while ((token = this.expect("==", "!=", "===", "!=="))) {
			left = {
				type: AST.BinaryExpression,
				operator: token.text,
				left: left,
				right: this.relational(),
			};
		}
		return left;
	},

	relational: function () {
		var left = this.additive();
		var token;
		while ((token = this.expect("<", ">", "<=", ">="))) {
			left = {
				type: AST.BinaryExpression,
				operator: token.text,
				left: left,
				right: this.additive(),
			};
		}
		return left;
	},

	additive: function () {
		var left = this.multiplicative();
		var token;
		while ((token = this.expect("+", "-"))) {
			left = {
				type: AST.BinaryExpression,
				operator: token.text,
				left: left,
				right: this.multiplicative(),
			};
		}
		return left;
	},

	multiplicative: function () {
		var left = this.unary();
		var token;
		while ((token = this.expect("*", "/", "%"))) {
			left = {
				type: AST.BinaryExpression,
				operator: token.text,
				left: left,
				right: this.unary(),
			};
		}
		return left;
	},

	unary: function () {
		var token;
		if ((token = this.expect("+", "-", "!"))) {
			return {
				type: AST.UnaryExpression,
				operator: token.text,
				prefix: true,
				argument: this.unary(),
			};
		} else {
			return this.primary();
		}
	},

	primary: function () {
		var primary;
		if (this.expect("(")) {
			primary = this.filterChain();
			this.consume(")");
		} else if (this.expect("[")) {
			primary = this.arrayDeclaration();
		} else if (this.expect("{")) {
			primary = this.object();
		} else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
			primary = copy(this.selfReferential[this.consume().text]);
		} else if (this.options.literals.hasOwnProperty(this.peek().text)) {
			primary = {
				type: AST.Literal,
				value: this.options.literals[this.consume().text],
			};
		} else if (this.peek().identifier) {
			primary = this.identifier();
		} else if (this.peek().constant) {
			primary = this.constant();
		} else {
			this.throwError("not a primary expression", this.peek());
		}

		var next;
		while ((next = this.expect("(", "[", "."))) {
			if (next.text === "(") {
				primary = {
					type: AST.CallExpression,
					callee: primary,
					arguments: this.parseArguments(),
				};
				this.consume(")");
			} else if (next.text === "[") {
				primary = {
					type: AST.MemberExpression,
					object: primary,
					property: this.expression(),
					computed: true,
				};
				this.consume("]");
			} else if (next.text === ".") {
				primary = {
					type: AST.MemberExpression,
					object: primary,
					property: this.identifier(),
					computed: false,
				};
			} else {
				this.throwError("IMPOSSIBLE");
			}
		}
		return primary;
	},

	filter: function (baseExpression) {
		var args = [baseExpression];
		var result = {
			type: AST.CallExpression,
			callee: this.identifier(),
			arguments: args,
			filter: true,
		};

		while (this.expect(":")) {
			args.push(this.expression());
		}

		return result;
	},

	parseArguments: function () {
		var args = [];
		if (this.peekToken().text !== ")") {
			do {
				args.push(this.filterChain());
			} while (this.expect(","));
		}
		return args;
	},

	identifier: function () {
		var token = this.consume();
		if (!token.identifier) {
			this.throwError("is not a valid identifier", token);
		}
		return { type: AST.Identifier, name: token.text };
	},

	constant: function () {
		// TODO check that it is a constant
		return { type: AST.Literal, value: this.consume().value };
	},

	arrayDeclaration: function () {
		var elements = [];
		if (this.peekToken().text !== "]") {
			do {
				if (this.peek("]")) {
					// Support trailing commas per ES5.1.
					break;
				}
				elements.push(this.expression());
			} while (this.expect(","));
		}
		this.consume("]");

		return { type: AST.ArrayExpression, elements: elements };
	},

	object: function () {
		var properties = [],
			property;
		if (this.peekToken().text !== "}") {
			do {
				if (this.peek("}")) {
					// Support trailing commas per ES5.1.
					break;
				}
				property = { type: AST.Property, kind: "init" };
				if (this.peek().constant) {
					property.key = this.constant();
					property.computed = false;
					this.consume(":");
					property.value = this.expression();
				} else if (this.peek().identifier) {
					property.key = this.identifier();
					property.computed = false;
					if (this.peek(":")) {
						this.consume(":");
						property.value = this.expression();
					} else {
						property.value = property.key;
					}
				} else if (this.peek("[")) {
					this.consume("[");
					property.key = this.expression();
					this.consume("]");
					property.computed = true;
					this.consume(":");
					property.value = this.expression();
				} else {
					this.throwError("invalid key", this.peek());
				}
				properties.push(property);
			} while (this.expect(","));
		}
		this.consume("}");

		return { type: AST.ObjectExpression, properties: properties };
	},

	throwError: function (msg, token) {
		throw $parseMinErr(
			"syntax",
			"Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].",
			token.text,
			msg,
			token.index + 1,
			this.text,
			this.text.substring(token.index)
		);
	},

	consume: function (e1) {
		if (this.tokens.length === 0) {
			throw $parseMinErr(
				"ueoe",
				"Unexpected end of expression: {0}",
				this.text
			);
		}

		var token = this.expect(e1);
		if (!token) {
			this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
		}
		return token;
	},

	peekToken: function () {
		if (this.tokens.length === 0) {
			throw $parseMinErr(
				"ueoe",
				"Unexpected end of expression: {0}",
				this.text
			);
		}
		return this.tokens[0];
	},

	peek: function (e1, e2, e3, e4) {
		return this.peekAhead(0, e1, e2, e3, e4);
	},

	peekAhead: function (i, e1, e2, e3, e4) {
		if (this.tokens.length > i) {
			var token = this.tokens[i];
			var t = token.text;
			if (
				t === e1 ||
				t === e2 ||
				t === e3 ||
				t === e4 ||
				(!e1 && !e2 && !e3 && !e4)
			) {
				return token;
			}
		}
		return false;
	},

	expect: function (e1, e2, e3, e4) {
		var token = this.peek(e1, e2, e3, e4);
		if (token) {
			this.tokens.shift();
			return token;
		}
		return false;
	},

	selfReferential: {
		this: { type: AST.ThisExpression },
		$locals: { type: AST.LocalsExpression },
	},
};

function ifDefined(v, d) {
	return typeof v !== "undefined" ? v : d;
}

function plusFn(l, r) {
	if (typeof l === "undefined") return r;
	if (typeof r === "undefined") return l;
	return l + r;
}

function isStateless($filter, filterName) {
	var fn = $filter(filterName);
	return !fn.$stateful;
}

function findConstantAndWatchExpressions(ast, $filter) {
	var allConstants;
	var argsToWatch;
	var isStatelessFilter;
	switch (ast.type) {
		case AST.Program:
			allConstants = true;
			forEach(ast.body, function (expr) {
				findConstantAndWatchExpressions(expr.expression, $filter);
				allConstants = allConstants && expr.expression.constant;
			});
			ast.constant = allConstants;
			break;
		case AST.Literal:
			ast.constant = true;
			ast.toWatch = [];
			break;
		case AST.UnaryExpression:
			findConstantAndWatchExpressions(ast.argument, $filter);
			ast.constant = ast.argument.constant;
			ast.toWatch = ast.argument.toWatch;
			break;
		case AST.BinaryExpression:
			findConstantAndWatchExpressions(ast.left, $filter);
			findConstantAndWatchExpressions(ast.right, $filter);
			ast.constant = ast.left.constant && ast.right.constant;
			ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
			break;
		case AST.LogicalExpression:
			findConstantAndWatchExpressions(ast.left, $filter);
			findConstantAndWatchExpressions(ast.right, $filter);
			ast.constant = ast.left.constant && ast.right.constant;
			ast.toWatch = ast.constant ? [] : [ast];
			break;
		case AST.ConditionalExpression:
			findConstantAndWatchExpressions(ast.test, $filter);
			findConstantAndWatchExpressions(ast.alternate, $filter);
			findConstantAndWatchExpressions(ast.consequent, $filter);
			ast.constant =
				ast.test.constant && ast.alternate.constant && ast.consequent.constant;
			ast.toWatch = ast.constant ? [] : [ast];
			break;
		case AST.Identifier:
			ast.constant = false;
			ast.toWatch = [ast];
			break;
		case AST.MemberExpression:
			findConstantAndWatchExpressions(ast.object, $filter);
			if (ast.computed) {
				findConstantAndWatchExpressions(ast.property, $filter);
			}
			ast.constant =
				ast.object.constant && (!ast.computed || ast.property.constant);
			ast.toWatch = [ast];
			break;
		case AST.CallExpression:
			isStatelessFilter = ast.filter
				? isStateless($filter, ast.callee.name)
				: false;
			allConstants = isStatelessFilter;
			argsToWatch = [];
			forEach(ast.arguments, function (expr) {
				findConstantAndWatchExpressions(expr, $filter);
				allConstants = allConstants && expr.constant;
				if (!expr.constant) {
					argsToWatch.push.apply(argsToWatch, expr.toWatch);
				}
			});
			ast.constant = allConstants;
			ast.toWatch = isStatelessFilter ? argsToWatch : [ast];
			break;
		case AST.AssignmentExpression:
			findConstantAndWatchExpressions(ast.left, $filter);
			findConstantAndWatchExpressions(ast.right, $filter);
			ast.constant = ast.left.constant && ast.right.constant;
			ast.toWatch = [ast];
			break;
		case AST.ArrayExpression:
			allConstants = true;
			argsToWatch = [];
			forEach(ast.elements, function (expr) {
				findConstantAndWatchExpressions(expr, $filter);
				allConstants = allConstants && expr.constant;
				if (!expr.constant) {
					argsToWatch.push.apply(argsToWatch, expr.toWatch);
				}
			});
			ast.constant = allConstants;
			ast.toWatch = argsToWatch;
			break;
		case AST.ObjectExpression:
			allConstants = true;
			argsToWatch = [];
			forEach(ast.properties, function (property) {
				findConstantAndWatchExpressions(property.value, $filter);
				allConstants =
					allConstants && property.value.constant && !property.computed;
				if (!property.value.constant) {
					argsToWatch.push.apply(argsToWatch, property.value.toWatch);
				}
			});
			ast.constant = allConstants;
			ast.toWatch = argsToWatch;
			break;
		case AST.ThisExpression:
			ast.constant = false;
			ast.toWatch = [];
			break;
		case AST.LocalsExpression:
			ast.constant = false;
			ast.toWatch = [];
			break;
	}
}

function getInputs(body) {
	if (body.length !== 1) return;
	var lastExpression = body[0].expression;
	var candidate = lastExpression.toWatch;
	if (candidate.length !== 1) return candidate;
	return candidate[0] !== lastExpression ? candidate : undefined;
}

function isAssignable(ast) {
	return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
}

function assignableAST(ast) {
	if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
		return {
			type: AST.AssignmentExpression,
			left: ast.body[0].expression,
			right: { type: AST.NGValueParameter },
			operator: "=",
		};
	}
}

function isLiteral(ast) {
	return (
		ast.body.length === 0 ||
		(ast.body.length === 1 &&
			(ast.body[0].expression.type === AST.Literal ||
				ast.body[0].expression.type === AST.ArrayExpression ||
				ast.body[0].expression.type === AST.ObjectExpression))
	);
}

function isConstant(ast) {
	return ast.constant;
}

function ASTCompiler(astBuilder, $filter) {
	this.astBuilder = astBuilder;
	this.$filter = $filter;
}

ASTCompiler.prototype = {
	compile: function (expression) {
		var self = this;
		var ast = this.astBuilder.ast(expression);
		this.state = {
			nextId: 0,
			filters: {},
			fn: { vars: [], body: [], own: {} },
			assign: { vars: [], body: [], own: {} },
			inputs: [],
		};
		findConstantAndWatchExpressions(ast, self.$filter);
		var extra = "";
		var assignable;
		this.stage = "assign";
		if ((assignable = assignableAST(ast))) {
			this.state.computing = "assign";
			var result = this.nextId();
			this.recurse(assignable, result);
			this.return_(result);
			extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
		}
		var toWatch = getInputs(ast.body);
		self.stage = "inputs";
		forEach(toWatch, function (watch, key) {
			var fnKey = "fn" + key;
			self.state[fnKey] = { vars: [], body: [], own: {} };
			self.state.computing = fnKey;
			var intoId = self.nextId();
			self.recurse(watch, intoId);
			self.return_(intoId);
			self.state.inputs.push(fnKey);
			watch.watchId = key;
		});
		this.state.computing = "fn";
		this.stage = "main";
		this.recurse(ast);
		var fnString =
			// The build and minification steps remove the string "use strict" from the code, but this is done using a regex.
			// This is a workaround for this until we do a better job at only removing the prefix only when we should.
			'"' +
			this.USE +
			" " +
			this.STRICT +
			'";\n' +
			this.filterPrefix() +
			"var fn=" +
			this.generateFunction("fn", "s,l,a,i") +
			extra +
			this.watchFns() +
			"return fn;";
		// eslint-disable-next-line no-new-func
		var fn = new Function(
			"$filter",
			"getStringValue",
			"ifDefined",
			"plus",
			fnString
		)(this.$filter, getStringValue, ifDefined, plusFn);

		this.state = this.stage = undefined;
		fn.ast = ast;
		fn.literal = isLiteral(ast);
		fn.constant = isConstant(ast);
		return fn;
	},

	USE: "use",

	STRICT: "strict",

	watchFns: function () {
		var result = [];
		var fns = this.state.inputs;
		var self = this;
		forEach(fns, function (name) {
			result.push("var " + name + "=" + self.generateFunction(name, "s"));
		});
		if (fns.length) {
			result.push("fn.inputs=[" + fns.join(",") + "];");
		}
		return result.join("");
	},

	generateFunction: function (name, params) {
		return (
			"function(" +
			params +
			"){" +
			this.varsPrefix(name) +
			this.body(name) +
			"};"
		);
	},

	filterPrefix: function () {
		var parts = [];
		var self = this;
		forEach(this.state.filters, function (id, filter) {
			parts.push(id + "=$filter(" + self.escape(filter) + ")");
		});
		if (parts.length) return "var " + parts.join(",") + ";";
		return "";
	},

	varsPrefix: function (section) {
		return this.state[section].vars.length
			? "var " + this.state[section].vars.join(",") + ";"
			: "";
	},

	body: function (section) {
		return this.state[section].body.join("");
	},

	recurse: function (
		ast,
		intoId,
		nameId,
		recursionFn,
		create,
		skipWatchIdCheck
	) {
		var left,
			right,
			self = this,
			args,
			expression,
			computed;
		recursionFn = recursionFn || noop;
		if (!skipWatchIdCheck && isDefined(ast.watchId)) {
			intoId = intoId || this.nextId();
			this.if_(
				"i",
				this.lazyAssign(intoId, this.unsafeComputedMember("i", ast.watchId)),
				this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)
			);
			return;
		}

		switch (ast.type) {
			case AST.Program:
				forEach(ast.body, function (expression, pos) {
					self.recurse(
						expression.expression,
						undefined,
						undefined,
						function (expr) {
							right = expr;
						}
					);
					if (pos !== ast.body.length - 1) {
						self.current().body.push(right, ";");
					} else {
						self.return_(right);
					}
				});
				break;
			case AST.Literal:
				expression = this.escape(ast.value);
				this.assign(intoId, expression);
				recursionFn(intoId || expression);
				break;
			case AST.UnaryExpression:
				this.recurse(ast.argument, undefined, undefined, function (expr) {
					right = expr;
				});
				expression = ast.operator + "(" + this.ifDefined(right, 0) + ")";
				this.assign(intoId, expression);
				recursionFn(expression);
				break;
			case AST.BinaryExpression:
				this.recurse(ast.left, undefined, undefined, function (expr) {
					left = expr;
				});
				this.recurse(ast.right, undefined, undefined, function (expr) {
					right = expr;
				});
				if (ast.operator === "+") {
					expression = this.plus(left, right);
				} else if (ast.operator === "-") {
					expression =
						this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
				} else {
					expression = "(" + left + ")" + ast.operator + "(" + right + ")";
				}
				this.assign(intoId, expression);
				recursionFn(expression);
				break;
			case AST.LogicalExpression:
				intoId = intoId || this.nextId();
				self.recurse(ast.left, intoId);
				self.if_(
					ast.operator === "&&" ? intoId : self.not(intoId),
					self.lazyRecurse(ast.right, intoId)
				);
				recursionFn(intoId);
				break;
			case AST.ConditionalExpression:
				intoId = intoId || this.nextId();
				self.recurse(ast.test, intoId);
				self.if_(
					intoId,
					self.lazyRecurse(ast.alternate, intoId),
					self.lazyRecurse(ast.consequent, intoId)
				);
				recursionFn(intoId);
				break;
			case AST.Identifier:
				intoId = intoId || this.nextId();
				if (nameId) {
					nameId.context =
						self.stage === "inputs"
							? "s"
							: this.assign(
									this.nextId(),
									this.getHasOwnProperty("l", ast.name) + "?l:s"
							  );
					nameId.computed = false;
					nameId.name = ast.name;
				}
				self.if_(
					self.stage === "inputs" ||
						self.not(self.getHasOwnProperty("l", ast.name)),
					function () {
						self.if_(
							self.stage === "inputs" ||
								self.and_(
									"s",
									self.or_(
										self.isNull(self.nonComputedMember("s", ast.name)),
										self.hasOwnProperty_("s", ast.name)
									)
								),
							function () {
								if (create && create !== 1) {
									self.if_(
										self.isNull(self.nonComputedMember("s", ast.name)),
										self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")
									);
								}
								self.assign(intoId, self.nonComputedMember("s", ast.name));
							}
						);
					},
					intoId &&
						self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))
				);
				recursionFn(intoId);
				break;
			case AST.MemberExpression:
				left = (nameId && (nameId.context = this.nextId())) || this.nextId();
				intoId = intoId || this.nextId();
				self.recurse(
					ast.object,
					left,
					undefined,
					function () {
						var member = null;
						const inAssignment = self.current().inAssignment;
						if (ast.computed) {
							right = self.nextId();
							if (inAssignment || self.state.computing === "assign") {
								member = self.unsafeComputedMember(left, right);
							} else {
								member = self.computedMember(left, right);
							}
						} else {
							if (inAssignment || self.state.computing === "assign") {
								member = self.unsafeNonComputedMember(left, ast.property.name);
							} else {
								member = self.nonComputedMember(left, ast.property.name);
							}
							right = ast.property.name;
						}

						if (ast.computed) {
							if (ast.property.type === AST.Literal) {
								self.recurse(ast.property, right);
							}
						}
						self.if_(
							self.and_(
								self.notNull(left),
								self.or_(
									self.isNull(member),
									self.hasOwnProperty_(left, right, ast.computed)
								)
							),
							function () {
								if (ast.computed) {
									if (ast.property.type !== AST.Literal) {
										self.recurse(ast.property, right);
									}
									if (create && create !== 1) {
										self.if_(self.not(member), self.lazyAssign(member, "{}"));
									}
									self.assign(intoId, member);
									if (nameId) {
										nameId.computed = true;
										nameId.name = right;
									}
								} else {
									if (create && create !== 1) {
										self.if_(
											self.isNull(member),
											self.lazyAssign(member, "{}")
										);
									}
									self.assign(intoId, member);
									if (nameId) {
										nameId.computed = false;
										nameId.name = ast.property.name;
									}
								}
							},
							function () {
								self.assign(intoId, "undefined");
							}
						);
						recursionFn(intoId);
					},
					!!create
				);
				break;
			case AST.CallExpression:
				intoId = intoId || this.nextId();
				if (ast.filter) {
					right = self.filter(ast.callee.name);
					args = [];
					forEach(ast.arguments, function (expr) {
						var argument = self.nextId();
						self.recurse(expr, argument);
						args.push(argument);
					});
					expression = right + ".call(" + right + "," + args.join(",") + ")";
					self.assign(intoId, expression);
					recursionFn(intoId);
				} else {
					right = self.nextId();
					left = {};
					args = [];
					self.recurse(ast.callee, right, left, function () {
						self.if_(
							self.notNull(right),
							function () {
								forEach(ast.arguments, function (expr) {
									self.recurse(
										expr,
										ast.constant ? undefined : self.nextId(),
										undefined,
										function (argument) {
											args.push(argument);
										}
									);
								});
								if (left.name) {
									var x = self.member(left.context, left.name, left.computed);
									expression =
										"(" +
										x +
										" === null ? null : " +
										self.unsafeMember(left.context, left.name, left.computed) +
										".call(" +
										[left.context].concat(args).join(",") +
										"))";
								} else {
									expression = right + "(" + args.join(",") + ")";
								}
								self.assign(intoId, expression);
							},
							function () {
								self.assign(intoId, "undefined");
							}
						);
						recursionFn(intoId);
					});
				}
				break;
			case AST.AssignmentExpression:
				right = this.nextId();
				left = {};
				self.current().inAssignment = true;
				this.recurse(
					ast.left,
					undefined,
					left,
					function () {
						self.if_(
							self.and_(
								self.notNull(left.context),
								self.or_(
									self.hasOwnProperty_(left.context, left.name),
									self.isNull(
										self.member(left.context, left.name, left.computed)
									)
								)
							),
							function () {
								self.recurse(ast.right, right);
								expression =
									self.member(left.context, left.name, left.computed) +
									ast.operator +
									right;
								self.assign(intoId, expression);
								recursionFn(intoId || expression);
							}
						);
						self.current().inAssignment = false;
						self.recurse(ast.right, right);
						self.current().inAssignment = true;
					},
					1
				);
				self.current().inAssignment = false;
				break;
			case AST.ArrayExpression:
				args = [];
				forEach(ast.elements, function (expr) {
					self.recurse(
						expr,
						ast.constant ? undefined : self.nextId(),
						undefined,
						function (argument) {
							args.push(argument);
						}
					);
				});
				expression = "[" + args.join(",") + "]";
				this.assign(intoId, expression);
				recursionFn(intoId || expression);
				break;
			case AST.ObjectExpression:
				args = [];
				computed = false;
				forEach(ast.properties, function (property) {
					if (property.computed) {
						computed = true;
					}
				});
				if (computed) {
					intoId = intoId || this.nextId();
					this.assign(intoId, "{}");
					forEach(ast.properties, function (property) {
						if (property.computed) {
							left = self.nextId();
							self.recurse(property.key, left);
						} else {
							left =
								property.key.type === AST.Identifier
									? property.key.name
									: "" + property.key.value;
						}
						right = self.nextId();
						self.recurse(property.value, right);
						self.assign(
							self.unsafeMember(intoId, left, property.computed),
							right
						);
					});
				} else {
					forEach(ast.properties, function (property) {
						self.recurse(
							property.value,
							ast.constant ? undefined : self.nextId(),
							undefined,
							function (expr) {
								args.push(
									self.escape(
										property.key.type === AST.Identifier
											? property.key.name
											: "" + property.key.value
									) +
										":" +
										expr
								);
							}
						);
					});
					expression = "{" + args.join(",") + "}";
					this.assign(intoId, expression);
				}
				recursionFn(intoId || expression);
				break;
			case AST.ThisExpression:
				this.assign(intoId, "s");
				recursionFn(intoId || "s");
				break;
			case AST.LocalsExpression:
				this.assign(intoId, "l");
				recursionFn(intoId || "l");
				break;
			case AST.NGValueParameter:
				this.assign(intoId, "v");
				recursionFn(intoId || "v");
				break;
		}
	},

	getHasOwnProperty: function (element, property) {
		var key = element + "." + property;
		var own = this.current().own;
		if (!own.hasOwnProperty(key)) {
			own[key] = this.nextId(
				false,
				element + "&&(" + this.escape(property) + " in " + element + ")"
			);
		}
		return own[key];
	},

	assign: function (id, value) {
		if (!id) return;
		this.current().body.push(id, "=", value, ";");
		return id;
	},

	filter: function (filterName) {
		if (!this.state.filters.hasOwnProperty(filterName)) {
			this.state.filters[filterName] = this.nextId(true);
		}
		return this.state.filters[filterName];
	},

	ifDefined: function (id, defaultValue) {
		return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
	},

	plus: function (left, right) {
		return "plus(" + left + "," + right + ")";
	},

	return_: function (id) {
		this.current().body.push("return ", id, ";");
	},

	if_: function (test, alternate, consequent) {
		if (test === true) {
			alternate();
		} else {
			var body = this.current().body;
			body.push("if(", test, "){");
			alternate();
			body.push("}");
			if (consequent) {
				body.push("else{");
				consequent();
				body.push("}");
			}
		}
	},
	or_: function (expr1, expr2) {
		return "(" + expr1 + ") || (" + expr2 + ")";
	},
	hasOwnProperty_: function (obj, prop, computed) {
		if (computed) {
			return "(Object.prototype.hasOwnProperty.call(" + obj + "," + prop + "))";
		} else {
			return (
				"(Object.prototype.hasOwnProperty.call(" + obj + ",'" + prop + "'))"
			);
		}
	},
	and_: function (expr1, expr2) {
		return "(" + expr1 + ") && (" + expr2 + ")";
	},
	not: function (expression) {
		return "!(" + expression + ")";
	},

	isNull: function (expression) {
		return expression + "==null";
	},

	notNull: function (expression) {
		return expression + "!=null";
	},

	nonComputedMember: function (left, right) {
		var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;
		var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
		var expr = "";
		if (SAFE_IDENTIFIER.test(right)) {
			expr = left + "." + right;
		} else {
			right = right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn);
			expr = left + '["' + right + '"]';
		}

		return expr;
	},

	unsafeComputedMember: function (left, right) {
		return left + "[" + right + "]";
	},
	unsafeNonComputedMember: function (left, right) {
		return this.nonComputedMember(left, right);
	},

	computedMember: function (left, right) {
		if (this.state.computing === "assign") {
			return this.unsafeComputedMember(left, right);
		}
		// return left + "[" + right + "]";
		return (
			"(" +
			left +
			".hasOwnProperty(" +
			right +
			") ? " +
			left +
			"[" +
			right +
			"] : null)"
		);
	},

	unsafeMember: function (left, right, computed) {
		if (computed) return this.unsafeComputedMember(left, right);
		return this.unsafeNonComputedMember(left, right);
	},

	member: function (left, right, computed) {
		if (computed) return this.computedMember(left, right);
		return this.nonComputedMember(left, right);
	},

	getStringValue: function (item) {
		this.assign(item, "getStringValue(" + item + ")");
	},

	lazyRecurse: function (
		ast,
		intoId,
		nameId,
		recursionFn,
		create,
		skipWatchIdCheck
	) {
		var self = this;
		return function () {
			self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
		};
	},

	lazyAssign: function (id, value) {
		var self = this;
		return function () {
			self.assign(id, value);
		};
	},

	stringEscapeRegex: /[^ a-zA-Z0-9]/g,

	stringEscapeFn: function (c) {
		return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
	},

	escape: function (value) {
		if (isString(value))
			return (
				"'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'"
			);
		if (isNumber(value)) return value.toString();
		if (value === true) return "true";
		if (value === false) return "false";
		if (value === null) return "null";
		if (typeof value === "undefined") return "undefined";

		throw $parseMinErr("esc", "IMPOSSIBLE");
	},

	nextId: function (skip, init) {
		var id = "v" + this.state.nextId++;
		if (!skip) {
			this.current().vars.push(id + (init ? "=" + init : ""));
		}
		return id;
	},

	current: function () {
		return this.state[this.state.computing];
	},
};

function ASTInterpreter(astBuilder, $filter) {
	this.astBuilder = astBuilder;
	this.$filter = $filter;
}

ASTInterpreter.prototype = {
	compile: function (expression) {
		var self = this;
		var ast = this.astBuilder.ast(expression);
		findConstantAndWatchExpressions(ast, self.$filter);
		var assignable;
		var assign;
		if ((assignable = assignableAST(ast))) {
			assign = this.recurse(assignable);
		}
		var toWatch = getInputs(ast.body);
		var inputs;
		if (toWatch) {
			inputs = [];
			forEach(toWatch, function (watch, key) {
				var input = self.recurse(watch);
				watch.input = input;
				inputs.push(input);
				watch.watchId = key;
			});
		}
		var expressions = [];
		forEach(ast.body, function (expression) {
			expressions.push(self.recurse(expression.expression));
		});
		var fn =
			ast.body.length === 0
				? noop
				: ast.body.length === 1
				? expressions[0]
				: function (scope, locals) {
						var lastValue;
						forEach(expressions, function (exp) {
							lastValue = exp(scope, locals);
						});
						return lastValue;
				  };

		if (assign) {
			fn.assign = function (scope, value, locals) {
				return assign(scope, locals, value);
			};
		}
		if (inputs) {
			fn.inputs = inputs;
		}
		fn.ast = ast;
		fn.literal = isLiteral(ast);
		fn.constant = isConstant(ast);
		return fn;
	},

	recurse: function (ast, context, create) {
		var left,
			right,
			self = this,
			args;
		if (ast.input) {
			return this.inputs(ast.input, ast.watchId);
		}
		switch (ast.type) {
			case AST.Literal:
				return this.value(ast.value, context);
			case AST.UnaryExpression:
				right = this.recurse(ast.argument);
				return this["unary" + ast.operator](right, context);
			case AST.BinaryExpression:
				left = this.recurse(ast.left);
				right = this.recurse(ast.right);
				return this["binary" + ast.operator](left, right, context);
			case AST.LogicalExpression:
				left = this.recurse(ast.left);
				right = this.recurse(ast.right);
				return this["binary" + ast.operator](left, right, context);
			case AST.ConditionalExpression:
				return this["ternary?:"](
					this.recurse(ast.test),
					this.recurse(ast.alternate),
					this.recurse(ast.consequent),
					context
				);
			case AST.Identifier:
				return self.identifier(ast.name, context, create);
			case AST.MemberExpression:
				left = this.recurse(ast.object, false, !!create);
				if (!ast.computed) {
					right = ast.property.name;
				}
				if (ast.computed) right = this.recurse(ast.property);

				return ast.computed
					? this.computedMember(left, right, context, create)
					: this.nonComputedMember(left, right, context, create);
			case AST.CallExpression:
				args = [];
				forEach(ast.arguments, function (expr) {
					args.push(self.recurse(expr));
				});
				if (ast.filter) right = this.$filter(ast.callee.name);
				if (!ast.filter) right = this.recurse(ast.callee, true);
				return ast.filter
					? function (scope, locals, assign, inputs) {
							var values = [];
							for (var i = 0; i < args.length; ++i) {
								values.push(args[i](scope, locals, assign, inputs));
							}
							var value = right.apply(undefined, values, inputs);
							return context
								? { context: undefined, name: undefined, value: value }
								: value;
					  }
					: function (scope, locals, assign, inputs) {
							var rhs = right(scope, locals, assign, inputs);
							var value;
							if (rhs.value != null) {
								var values = [];
								for (var i = 0; i < args.length; ++i) {
									values.push(args[i](scope, locals, assign, inputs));
								}
								value = rhs.value.apply(rhs.context, values);
							}
							return context ? { value: value } : value;
					  };
			case AST.AssignmentExpression:
				left = this.recurse(ast.left, true, 1);
				right = this.recurse(ast.right);
				return function (scope, locals, assign, inputs) {
					var lhs = left(scope, locals, assign, inputs);
					var rhs = right(scope, locals, assign, inputs);
					lhs.context[lhs.name] = rhs;
					return context ? { value: rhs } : rhs;
				};
			case AST.ArrayExpression:
				args = [];
				forEach(ast.elements, function (expr) {
					args.push(self.recurse(expr));
				});
				return function (scope, locals, assign, inputs) {
					var value = [];
					for (var i = 0; i < args.length; ++i) {
						value.push(args[i](scope, locals, assign, inputs));
					}
					return context ? { value: value } : value;
				};
			case AST.ObjectExpression:
				args = [];
				forEach(ast.properties, function (property) {
					if (property.computed) {
						args.push({
							key: self.recurse(property.key),
							computed: true,
							value: self.recurse(property.value),
						});
					} else {
						args.push({
							key:
								property.key.type === AST.Identifier
									? property.key.name
									: "" + property.key.value,
							computed: false,
							value: self.recurse(property.value),
						});
					}
				});
				return function (scope, locals, assign, inputs) {
					var value = {};
					for (var i = 0; i < args.length; ++i) {
						if (args[i].computed) {
							value[args[i].key(scope, locals, assign, inputs)] = args[i].value(
								scope,
								locals,
								assign,
								inputs
							);
						} else {
							value[args[i].key] = args[i].value(scope, locals, assign, inputs);
						}
					}
					return context ? { value: value } : value;
				};
			case AST.ThisExpression:
				return function (scope) {
					return context ? { value: scope } : scope;
				};
			case AST.LocalsExpression:
				return function (scope, locals) {
					return context ? { value: locals } : locals;
				};
			case AST.NGValueParameter:
				return function (scope, locals, assign) {
					return context ? { value: assign } : assign;
				};
		}
	},

	"unary+": function (argument, context) {
		return function (scope, locals, assign, inputs) {
			var arg = argument(scope, locals, assign, inputs);
			if (isDefined(arg)) {
				arg = +arg;
			} else {
				arg = 0;
			}
			return context ? { value: arg } : arg;
		};
	},
	"unary-": function (argument, context) {
		return function (scope, locals, assign, inputs) {
			var arg = argument(scope, locals, assign, inputs);
			if (isDefined(arg)) {
				arg = -arg;
			} else {
				arg = -0;
			}
			return context ? { value: arg } : arg;
		};
	},
	"unary!": function (argument, context) {
		return function (scope, locals, assign, inputs) {
			var arg = !argument(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary+": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var lhs = left(scope, locals, assign, inputs);
			var rhs = right(scope, locals, assign, inputs);
			var arg = plusFn(lhs, rhs);
			return context ? { value: arg } : arg;
		};
	},
	"binary-": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var lhs = left(scope, locals, assign, inputs);
			var rhs = right(scope, locals, assign, inputs);
			var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
			return context ? { value: arg } : arg;
		};
	},
	"binary*": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var arg =
				left(scope, locals, assign, inputs) *
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary/": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var arg =
				left(scope, locals, assign, inputs) /
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary%": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var arg =
				left(scope, locals, assign, inputs) %
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary===": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var arg =
				left(scope, locals, assign, inputs) ===
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary!==": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var arg =
				left(scope, locals, assign, inputs) !==
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary==": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			// eslint-disable-next-line eqeqeq
			var arg =
				left(scope, locals, assign, inputs) ==
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary!=": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			// eslint-disable-next-line eqeqeq
			var arg =
				left(scope, locals, assign, inputs) !=
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary<": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var arg =
				left(scope, locals, assign, inputs) <
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary>": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var arg =
				left(scope, locals, assign, inputs) >
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary<=": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var arg =
				left(scope, locals, assign, inputs) <=
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary>=": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var arg =
				left(scope, locals, assign, inputs) >=
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary&&": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var arg =
				left(scope, locals, assign, inputs) &&
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"binary||": function (left, right, context) {
		return function (scope, locals, assign, inputs) {
			var arg =
				left(scope, locals, assign, inputs) ||
				right(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	"ternary?:": function (test, alternate, consequent, context) {
		return function (scope, locals, assign, inputs) {
			var arg = test(scope, locals, assign, inputs)
				? alternate(scope, locals, assign, inputs)
				: consequent(scope, locals, assign, inputs);
			return context ? { value: arg } : arg;
		};
	},
	value: function (value, context) {
		return function () {
			return context
				? { context: undefined, name: undefined, value: value }
				: value;
		};
	},
	identifier: function (name, context, create) {
		return function (scope, locals, assign, inputs) {
			var base = locals && name in locals ? locals : scope;
			if (create && create !== 1 && base && base[name] == null) {
				base[name] = {};
			}
			var value = base ? base[name] : undefined;
			if (context) {
				return { context: base, name: name, value: value };
			} else {
				return value;
			}
		};
	},
	computedMember: function (left, right, context, create) {
		return function (scope, locals, assign, inputs) {
			var lhs = left(scope, locals, assign, inputs);
			var rhs;
			var value;
			if (lhs != null) {
				rhs = right(scope, locals, assign, inputs);
				rhs = getStringValue(rhs);
				if (create && create !== 1) {
					if (lhs && !lhs[rhs]) {
						lhs[rhs] = {};
					}
				}
				if (Object.prototype.hasOwnProperty.call(lhs, rhs)) {
					value = lhs[rhs];
				}
			}
			if (context) {
				return { context: lhs, name: rhs, value: value };
			} else {
				return value;
			}
		};
	},
	nonComputedMember: function (left, right, context, create) {
		return function (scope, locals, assign, inputs) {
			var lhs = left(scope, locals, assign, inputs);
			if (create && create !== 1) {
				if (lhs && lhs[right] == null) {
					lhs[right] = {};
				}
			}
			var value = undefined;
			if (lhs != null && Object.prototype.hasOwnProperty.call(lhs, right)) {
				value = lhs[right];
			}

			if (context) {
				return { context: lhs, name: right, value: value };
			} else {
				return value;
			}
		};
	},
	inputs: function (input, watchId) {
		return function (scope, value, locals, inputs) {
			if (inputs) return inputs[watchId];
			return input(scope, value, locals);
		};
	},
};

/**
 * @constructor
 */
var Parser = function Parser(lexer, $filter, options) {
	this.lexer = lexer;
	this.$filter = $filter;
	this.options = options;
	this.ast = new AST(lexer, options);
	this.astCompiler = options.csp
		? new ASTInterpreter(this.ast, $filter)
		: new ASTCompiler(this.ast, $filter);
};

Parser.prototype = {
	constructor: Parser,

	parse: function (text) {
		return this.astCompiler.compile(text);
	},
};

function getValueOf(value) {
	return isFunction(value.valueOf)
		? value.valueOf()
		: objectValueOf.call(value);
}

///////////////////////////////////

/**
 * @ngdoc service
 * @name $parse
 * @kind function
 *
 * @description
 *
 * Converts Angular {@link guide/expression expression} into a function.
 *
 * ```js
 *   var getter = $parse('user.name');
 *   var setter = getter.assign;
 *   var context = {user:{name:'angular'}};
 *   var locals = {user:{name:'local'}};
 *
 *   expect(getter(context)).toEqual('angular');
 *   setter(context, 'newValue');
 *   expect(context.user.name).toEqual('newValue');
 *   expect(getter(context, locals)).toEqual('local');
 * ```
 *
 *
 * @param {string} expression String expression to compile.
 * @returns {function(context, locals)} a function which represents the compiled expression:
 *
 *    * `context`  `{object}`  an object against which any expressions embedded in the strings
 *      are evaluated against (typically a scope object).
 *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
 *      `context`.
 *
 *    The returned function also has the following properties:
 *      * `literal`  `{boolean}`  whether the expression's top-level node is a JavaScript
 *        literal.
 *      * `constant`  `{boolean}`  whether the expression is made entirely of JavaScript
 *        constant literals.
 *      * `assign`  `{?function(context, value)}`  if the expression is assignable, this will be
 *        set to a function to change its value on the given context.
 *
 */

/**
 * @ngdoc provider
 * @name $parseProvider
 * @this
 *
 * @description
 * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}
 *  service.
 */
function $ParseProvider() {
	var cache = createMap();
	var literals = {
		true: true,
		false: false,
		null: null,
		undefined: undefined,
	};
	var identStart, identContinue;

	/**
	 * @ngdoc method
	 * @name $parseProvider#addLiteral
	 * @description
	 *
	 * Configure $parse service to add literal values that will be present as literal at expressions.
	 *
	 * @param {string} literalName Token for the literal value. The literal name value must be a valid literal name.
	 * @param {*} literalValue Value for this literal. All literal values must be primitives or `undefined`.
	 *
	 **/
	this.addLiteral = function (literalName, literalValue) {
		literals[literalName] = literalValue;
	};

	/**
	 * @ngdoc method
	 * @name $parseProvider#setIdentifierFns
	 *
	 * @description
	 *
	 * Allows defining the set of characters that are allowed in Angular expressions. The function
	 * `identifierStart` will get called to know if a given character is a valid character to be the
	 * first character for an identifier. The function `identifierContinue` will get called to know if
	 * a given character is a valid character to be a follow-up identifier character. The functions
	 * `identifierStart` and `identifierContinue` will receive as arguments the single character to be
	 * identifier and the character code point. These arguments will be `string` and `numeric`. Keep in
	 * mind that the `string` parameter can be two characters long depending on the character
	 * representation. It is expected for the function to return `true` or `false`, whether that
	 * character is allowed or not.
	 *
	 * Since this function will be called extensively, keep the implementation of these functions fast,
	 * as the performance of these functions have a direct impact on the expressions parsing speed.
	 *
	 * @param {function=} identifierStart The function that will decide whether the given character is
	 *   a valid identifier start character.
	 * @param {function=} identifierContinue The function that will decide whether the given character is
	 *   a valid identifier continue character.
	 */
	this.setIdentifierFns = function (identifierStart, identifierContinue) {
		identStart = identifierStart;
		identContinue = identifierContinue;
		return this;
	};

	this.$get = [
		"$filter",
		function ($filter) {
			var noUnsafeEval = csp().noUnsafeEval;
			var $parseOptions = {
				csp: noUnsafeEval,
				literals: copy(literals),
				isIdentifierStart: isFunction(identStart) && identStart,
				isIdentifierContinue: isFunction(identContinue) && identContinue,
			};
			return $parse;

			function $parse(exp, interceptorFn) {
				var parsedExpression, oneTime, cacheKey;

				switch (typeof exp) {
					case "string":
						exp = exp.trim();
						cacheKey = exp;

						parsedExpression = cache[cacheKey];

						if (!parsedExpression) {
							if (exp.charAt(0) === ":" && exp.charAt(1) === ":") {
								oneTime = true;
								exp = exp.substring(2);
							}
							var lexer = new Lexer($parseOptions);
							var parser = new Parser(lexer, $filter, $parseOptions);
							parsedExpression = parser.parse(exp);
							if (parsedExpression.constant) {
								parsedExpression.$$watchDelegate = constantWatchDelegate;
							} else if (oneTime) {
								parsedExpression.$$watchDelegate = parsedExpression.literal
									? oneTimeLiteralWatchDelegate
									: oneTimeWatchDelegate;
							} else if (parsedExpression.inputs) {
								parsedExpression.$$watchDelegate = inputsWatchDelegate;
							}
							cache[cacheKey] = parsedExpression;
						}
						return addInterceptor(parsedExpression, interceptorFn);

					case "function":
						return addInterceptor(exp, interceptorFn);

					default:
						return addInterceptor(noop, interceptorFn);
				}
			}

			function expressionInputDirtyCheck(newValue, oldValueOfValue) {
				if (newValue == null || oldValueOfValue == null) {
					// null/undefined
					return newValue === oldValueOfValue;
				}

				if (typeof newValue === "object") {
					// attempt to convert the value to a primitive type
					// TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can
					//             be cheaply dirty-checked
					newValue = getValueOf(newValue);

					if (typeof newValue === "object") {
						// objects/arrays are not supported - deep-watching them would be too expensive
						return false;
					}

					// fall-through to the primitive equality check
				}

				//Primitive or NaN
				// eslint-disable-next-line no-self-compare
				return (
					newValue === oldValueOfValue ||
					(newValue !== newValue && oldValueOfValue !== oldValueOfValue)
				);
			}

			function inputsWatchDelegate(
				scope,
				listener,
				objectEquality,
				parsedExpression,
				prettyPrintExpression
			) {
				var inputExpressions = parsedExpression.inputs;
				var lastResult;

				if (inputExpressions.length === 1) {
					var oldInputValueOf = expressionInputDirtyCheck; // init to something unique so that equals check fails
					inputExpressions = inputExpressions[0];
					return scope.$watch(
						function expressionInputWatch(scope) {
							var newInputValue = inputExpressions(scope);
							if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
								lastResult = parsedExpression(scope, undefined, undefined, [
									newInputValue,
								]);
								oldInputValueOf = newInputValue && getValueOf(newInputValue);
							}
							return lastResult;
						},
						listener,
						objectEquality,
						prettyPrintExpression
					);
				}

				var oldInputValueOfValues = [];
				var oldInputValues = [];
				for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
					oldInputValueOfValues[i] = expressionInputDirtyCheck; // init to something unique so that equals check fails
					oldInputValues[i] = null;
				}

				return scope.$watch(
					function expressionInputsWatch(scope) {
						var changed = false;

						for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
							var newInputValue = inputExpressions[i](scope);
							if (
								changed ||
								(changed = !expressionInputDirtyCheck(
									newInputValue,
									oldInputValueOfValues[i]
								))
							) {
								oldInputValues[i] = newInputValue;
								oldInputValueOfValues[i] =
									newInputValue && getValueOf(newInputValue);
							}
						}

						if (changed) {
							lastResult = parsedExpression(
								scope,
								undefined,
								undefined,
								oldInputValues
							);
						}

						return lastResult;
					},
					listener,
					objectEquality,
					prettyPrintExpression
				);
			}

			function oneTimeWatchDelegate(
				scope,
				listener,
				objectEquality,
				parsedExpression,
				prettyPrintExpression
			) {
				var unwatch, lastValue;
				if (parsedExpression.inputs) {
					unwatch = inputsWatchDelegate(
						scope,
						oneTimeListener,
						objectEquality,
						parsedExpression,
						prettyPrintExpression
					);
				} else {
					unwatch = scope.$watch(oneTimeWatch, oneTimeListener, objectEquality);
				}
				return unwatch;

				function oneTimeWatch(scope) {
					return parsedExpression(scope);
				}
				function oneTimeListener(value, old, scope) {
					lastValue = value;
					if (isFunction(listener)) {
						listener(value, old, scope);
					}
					if (isDefined(value)) {
						scope.$$postDigest(function () {
							if (isDefined(lastValue)) {
								unwatch();
							}
						});
					}
				}
			}

			function oneTimeLiteralWatchDelegate(
				scope,
				listener,
				objectEquality,
				parsedExpression
			) {
				var unwatch, lastValue;
				unwatch = scope.$watch(
					function oneTimeWatch(scope) {
						return parsedExpression(scope);
					},
					function oneTimeListener(value, old, scope) {
						lastValue = value;
						if (isFunction(listener)) {
							listener(value, old, scope);
						}
						if (isAllDefined(value)) {
							scope.$$postDigest(function () {
								if (isAllDefined(lastValue)) unwatch();
							});
						}
					},
					objectEquality
				);

				return unwatch;

				function isAllDefined(value) {
					var allDefined = true;
					forEach(value, function (val) {
						if (!isDefined(val)) allDefined = false;
					});
					return allDefined;
				}
			}

			function constantWatchDelegate(
				scope,
				listener,
				objectEquality,
				parsedExpression
			) {
				var unwatch = scope.$watch(
					function constantWatch(scope) {
						unwatch();
						return parsedExpression(scope);
					},
					listener,
					objectEquality
				);
				return unwatch;
			}

			function addInterceptor(parsedExpression, interceptorFn) {
				if (!interceptorFn) return parsedExpression;
				var watchDelegate = parsedExpression.$$watchDelegate;
				var useInputs = false;

				var regularWatch =
					watchDelegate !== oneTimeLiteralWatchDelegate &&
					watchDelegate !== oneTimeWatchDelegate;

				var fn = regularWatch
					? function regularInterceptedExpression(
							scope,
							locals,
							assign,
							inputs
					  ) {
							var value =
								useInputs && inputs
									? inputs[0]
									: parsedExpression(scope, locals, assign, inputs);
							return interceptorFn(value, scope, locals);
					  }
					: function oneTimeInterceptedExpression(
							scope,
							locals,
							assign,
							inputs
					  ) {
							var value = parsedExpression(scope, locals, assign, inputs);
							var result = interceptorFn(value, scope, locals);
							// we only return the interceptor's result if the
							// initial value is defined (for bind-once)
							return isDefined(value) ? result : value;
					  };

				// Propagate $$watchDelegates other then inputsWatchDelegate
				useInputs = !parsedExpression.inputs;
				if (
					parsedExpression.$$watchDelegate &&
					parsedExpression.$$watchDelegate !== inputsWatchDelegate
				) {
					fn.$$watchDelegate = parsedExpression.$$watchDelegate;
					fn.inputs = parsedExpression.inputs;
				} else if (!interceptorFn.$stateful) {
					// If there is an interceptor, but no watchDelegate then treat the interceptor like
					// we treat filters - it is assumed to be a pure function unless flagged with $stateful
					fn.$$watchDelegate = inputsWatchDelegate;
					fn.inputs = parsedExpression.inputs
						? parsedExpression.inputs
						: [parsedExpression];
				}

				return fn;
			}
		},
	];
}

exports.Lexer = Lexer;
exports.Parser = Parser;
